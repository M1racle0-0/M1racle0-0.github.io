<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>UE4笔记（五）</title>
      <link href="/2020/07/19/%E8%99%9A%E5%B9%BB%E5%9B%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2020/07/19/%E8%99%9A%E5%B9%BB%E5%9B%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="UE4学习笔记（五"><a href="#UE4学习笔记（五" class="headerlink" title="UE4学习笔记（五)"></a>UE4学习笔记（五)</h1><h2 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h2><h3 id="PBR"><a href="#PBR" class="headerlink" title="PBR"></a>PBR</h3><p>PBR的全称为 Physical Based Rendering(基于物理的渲染)，基于物理的渲染意味着我们根据事实模拟光线，而不是根据主观想法，光线的最终效果会更加准确且自然。</p><p>PBR是两个做卡通渲染风格的工作室合作的产物，因此PBR在卡通渲染方面也很不错，PBR有助于我们变准话美工管线，因为材质无论遇到怎样的光照都能做出相同反应（这意味着我们不需要根据物体的光照环境创建多个材质或者纹理）</p><p><u>This is the same type of redering pipeline that you will find in programs like Vary.</u></p><h3 id="材质域-Material-Domain"><a href="#材质域-Material-Domain" class="headerlink" title="材质域(Material Domain)"></a>材质域(Material Domain)</h3><p>只需要改变材质域、混合模式和着色模式就可以变换材质来满足各种不同的需求。</p><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200515160927312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>Material Domain (材质域）决定了材质属性的评估方式</p><p>Blend Mode（混合模式） 决定了材质的颜色，以及材质与背景融合的方式</p><p>Shading Modeal（着色模型） 决定了输入将如何䄦来创建材质的最终颜色</p><p><u>例如，如果你想实现玻璃材质，应该讲混合模式改为“透明”，根据你是否希望玻璃对光线做出反应，将着色模型改为“无光照”或者“默认带光照”</u></p><p>材质域、混合模式和着色模型不能在运行时更改</p><h3 id="What-is-a-Material？-材质"><a href="#What-is-a-Material？-材质" class="headerlink" title="What is a Material？(材质)"></a>What is a Material？(材质)</h3><p>材质是UE4用于表示并调整对象纹理外观的方式，使用材质编辑器创建。材质实际上是由一块一块的HLSL（高级着色器语言）组成，UE4材质编辑中的许多函数都是直接由HLSL函数构成的。</p><p>材质需要先编译才能在游戏中使用或者显示。一旦材质被编译好了，它就变成静态的了，不能在程序运行时更改。</p><p>可以使用一种材质将其应用到项目中的各种不同材质上。</p><h3 id="材质实例（Meterial-Instance）"><a href="#材质实例（Meterial-Instance）" class="headerlink" title="材质实例（Meterial Instance）"></a>材质实例（Meterial Instance）</h3><p>上个模块我们提到不可以在运行时更改材质，这个特性会对当下的游戏开发带了不少的困扰，例如动态的游戏场景，而材质实例就是为了解决这个问题存在的。</p><p>材质实例是材质的特殊版本。它允许我们在游戏运行的时候修改材质中的参数和纹理而不需要重新编译材质，这让材质实例的迭代变得非常快，所以你几乎可以实时看到变化效果，你还可以通过时间轴和蓝图与材质实例进行交互。</p><p>当你使用单独的材质实例的时候，其性能优势很有限，而当你使用大量的材质实例而不是材质的时候他的性能优势就会逐渐显示出来。</p><p>材质实例非常的灵活，你可以设置一个主材质，然后在材质实例中设置许多的参数以便后期调整材质，而无需编写大量复杂的着色器代码（Shader Code）。</p><h3 id="主材质（Master-Material"><a href="#主材质（Master-Material" class="headerlink" title="主材质（Master Material)"></a>主材质（Master Material)</h3><p>主材质是一种用未完成许多任务的材质，可以在项目中满足对象的不同材质需求</p><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200515164106538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200515164117415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>左侧是Base_Color 可以使用取色器将材质设置成任意颜色</p><p>右侧是纹理参数节点，它允许我们在材质实例中添加任意纹理</p><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200515164341431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>标量参数，标量参数控制标量变量，允许我们更改材质实例中的参数，以便增加或者减少材质实例的某种效果</p><h4 id="主材质的注意事项"><a href="#主材质的注意事项" class="headerlink" title="主材质的注意事项"></a>主材质的注意事项</h4><p>不要尝试将一种主材质用于所有对象，它会让材质臃肿不堪，最终导致性能问题，可以所有的透明物体使用一种材质，所有的半透明使用一种，主角使用一种，武器使用一种。</p><h2 id="主材质的概念"><a href="#主材质的概念" class="headerlink" title="主材质的概念"></a>主材质的概念</h2><h3 id="材质函数（Material-Function）"><a href="#材质函数（Material-Function）" class="headerlink" title="材质函数（Material Function）"></a>材质函数（Material Function）</h3><p>材质函数允许你共享并复用材质图标的部分内容。UE4自带了诸多材质函数，比如确定场景对象的位置、鼠标在屏幕中位置等函数。你可以方便地将代码封装成材质函数，然后通过材质库分享代码。</p><p>材质函数允许你共享材质代码，从而在你调整全局效果时减少维护代码的麻烦</p><h3 id="RGB遮罩打包（RGB-Mask-Packing）"><a href="#RGB遮罩打包（RGB-Mask-Packing）" class="headerlink" title="RGB遮罩打包（RGB Mask Packing）"></a>RGB遮罩打包（RGB Mask Packing）</h3><p>将不同的纹理保存在同一张纹理的RGB通道中，能有效的减少纹理的占用量。</p><p>在使用RGB遮罩打包的时候要注明RGB通道中各自保存的纹理类型。</p><h3 id="静态开关-Static-switches"><a href="#静态开关-Static-switches" class="headerlink" title="静态开关 (Static switches)"></a>静态开关 (Static switches)</h3><p>他允许你启用或者禁用材质中的整条代码路径。<br>        <u>比如你可以将视差法线贴图放在静态开关内，因为其开销很大，所以可以只在需要的时候开启它就可以了。</u></p><h3 id="特性层级开关（Feature-Level-Switch）"><a href="#特性层级开关（Feature-Level-Switch）" class="headerlink" title="特性层级开关（Feature Level Switch）"></a>特性层级开关（Feature Level Switch）</h3><p>它可以让材质在任何目标设备上运行。</p><p><u>例如ES2：用于安卓等移动设备。SM5可以获得最高等级的精细度</u></p><h2 id="实践部分"><a href="#实践部分" class="headerlink" title="实践部分"></a>实践部分</h2><h3 id="主材质"><a href="#主材质" class="headerlink" title="主材质"></a>主材质</h3><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200515223946279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>简单讲一下 </p><p>在UE4中创建一个新的材质，完成相关的蓝图设计。</p><p>这张图创建的材质包括了底色（Base Color)，金属(Metallic)，粗糙程度(Roughness)，法线贴图(Normal) </p><p>在Base_color中有一个Swtich判断显示纹理还是显示取色器颜色。</p><p>Meallic中添加一个参数控制金属光泽</p><p>在Roughness中 lerp()函数为线性插值函数，能上调或调低粗糙度数值，先导入粗糙纹理，在纹理取样类型设置中改为“遮罩”并转换成参数，中间来获取遮罩参数，筛选纹理的RGB通道再连接至lerp函数中的阿尔法通道，通过两个参数的调节控制粗糙程度</p><p>导入法线贴图，将采样类型设置为法线。</p><p>完成主材质制作。 更名、分组对于后期管理很重要。</p><h4 id="改为玻璃对象的主材质"><a href="#改为玻璃对象的主材质" class="headerlink" title="改为玻璃对象的主材质"></a>改为玻璃对象的主材质</h4><p>玻璃的主要属性就是透明，然而我们发现现在主材质的Opacity属性是黑色的，即不可操作。而要打开这个参数我们需要将主材质的属性切换为Translucent，然后就会发现粗糙度相关的点变为了不可操作，而Opacity被打开了。我们按住1点击屏幕创建一个常量，将其链接到Opacity上，即可调整当前材质的透明度。</p><h3 id="材质函数"><a href="#材质函数" class="headerlink" title="材质函数"></a>材质函数</h3><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200516122149422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>创建材质函数，进入蓝图进行创建 <u>控制纹理缩放的材质函数</u></p><p>TexCoord[0]是贴图坐标系，它反映的是只坐标的变化。<br>        Input Texture_Scaling是一个输入节点，在这里我们用来表示坐标缩放的大小。<br>        Multiply是相乘的意思，即将坐标与缩放相乘获得最终的坐标，然后相乘的坐标作为输出结果</p><h4 id="材质函数的应用"><a href="#材质函数的应用" class="headerlink" title="材质函数的应用"></a>材质函数的应用</h4><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200516122727116.png" alt=""></p><p>将材质函数拖入主材质中，MF_Title 为拖入的材质函数，在左侧创建一个参数作为函数的输入，控制缩放的材质大小</p><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200516122852524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>将函数的输出与纹理、粗糙度等建立联系，输入位置为UVs</p><h3 id="材质实例"><a href="#材质实例" class="headerlink" title="材质实例"></a>材质实例</h3><p>材质实例和主材质具有父子关系，子类只能继承或使用父类拥有的属性。</p><h4 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h4><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200516153410274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>1.左侧，右键点击一个材质，在弹出的菜单中选择创建材质实例<br>        2.在内容浏览器的空白处右键可以在材质子菜单中找到材质实例</p><h4 id="材质实例的使用"><a href="#材质实例的使用" class="headerlink" title="材质实例的使用"></a>材质实例的使用</h4><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200516160627181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>可以看见他包含了我刚才创建的Base_Color、Metallic、Normal、Roughness。</p><p>Scalar Parameter Values中包含控制创建的材质函数输入值，相当于其他选项。（因为没有直接连接到主材质上</p><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200516214329317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>在通用字段下可以修改父材质的属性和函数。</p><p>【two sides】：双面。如果勾选中了这个属性，则材质将会双面渲染，双面指的是内面和外面。</p><p>【Dithered LODTransition】：颤化LOD过滤。它用于植被系统。（这个选项违背了父材质系统的初衷，因此请谨慎使用）</p><p>【Shading Model】：如果不想创建材质又想快速的看到效果可以使用这个东西。</p><h2 id="顶点动画"><a href="#顶点动画" class="headerlink" title="顶点动画"></a>顶点动画</h2><p>顶点动画以极低的开销实现复杂对象的微妙运动，如水面、树叶、布料等。顶点动画完全由GPU完成，完全不使用CPU。这使得每一帧的渲染开销都很低。</p><p>缺点是其互动性低，即CPU和我们所处理的逻辑无法获取到动画的偏移量。因此无法用于任何与游戏互动相关的部分，比如交互和碰撞。</p><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200516220152564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>在这颗植物中，只有叶子在随风飘摇，而树干则没有动态的效果。因此我们需要将叶子与树干分离，使用两个静态网格体或者使用两个不同的材质，如上图。其中TreeBark材质为静态的材质，而下面的CherryTree_Wind则是设置了顶点动画的材质。</p><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200516220525736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>其中上侧的TextureSample设置为Mask，将其RGB链接到BaseColor成为底色，而Alpha链接到OpacityMask上。同时拖入一张法线贴图，使其拥有法线效果。</p><p>这样一张静态的材质就做好了。</p><p>而动态的产生依赖于左边的3个模块，分别是两个常量和一个SimpleGrassWind效果，图中链接的3个常量点是必须要设置的参数，设置后将风模块链接到主材质的World Position Offset，即可将风的动态效果映射到世界坐标偏移上，从而产生动态的效果，注意选择双面。</p>]]></content>
      
      
      
        <tags>
            
            <tag> UE4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻四笔记（五）</title>
      <link href="/2020/07/19/%E8%99%9A%E5%B9%BB%E5%9B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2020/07/19/%E8%99%9A%E5%B9%BB%E5%9B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="UE4笔记（五"><a href="#UE4笔记（五" class="headerlink" title="UE4笔记（五)"></a>UE4笔记（五)</h1><h2 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h2><h3 id="PBR"><a href="#PBR" class="headerlink" title="PBR"></a>PBR</h3><p>PBR的全称为 Physical Based Rendering(基于物理的渲染)，基于物理的渲染意味着我们根据事实模拟光线，而不是根据主观想法，光线的最终效果会更加准确且自然。</p><p>PBR是两个做卡通渲染风格的工作室合作的产物，因此PBR在卡通渲染方面也很不错，PBR有助于我们变准话美工管线，因为材质无论遇到怎样的光照都能做出相同反应（这意味着我们不需要根据物体的光照环境创建多个材质或者纹理）</p><p><u>This is the same type of redering pipeline that you will find in programs like Vary.</u></p><h3 id="材质域-Material-Domain"><a href="#材质域-Material-Domain" class="headerlink" title="材质域(Material Domain)"></a>材质域(Material Domain)</h3><p>只需要改变材质域、混合模式和着色模式就可以变换材质来满足各种不同的需求。</p><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200515160927312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>Material Domain (材质域）决定了材质属性的评估方式</p><p>Blend Mode（混合模式） 决定了材质的颜色，以及材质与背景融合的方式</p><p>Shading Modeal（着色模型） 决定了输入将如何䄦来创建材质的最终颜色</p><p><u>例如，如果你想实现玻璃材质，应该讲混合模式改为“透明”，根据你是否希望玻璃对光线做出反应，将着色模型改为“无光照”或者“默认带光照”</u></p><p>材质域、混合模式和着色模型不能在运行时更改</p><h3 id="What-is-a-Material？-材质"><a href="#What-is-a-Material？-材质" class="headerlink" title="What is a Material？(材质)"></a>What is a Material？(材质)</h3><p>材质是UE4用于表示并调整对象纹理外观的方式，使用材质编辑器创建。材质实际上是由一块一块的HLSL（高级着色器语言）组成，UE4材质编辑中的许多函数都是直接由HLSL函数构成的。</p><p>材质需要先编译才能在游戏中使用或者显示。一旦材质被编译好了，它就变成静态的了，不能在程序运行时更改。</p><p>可以使用一种材质将其应用到项目中的各种不同材质上。</p><h3 id="材质实例（Meterial-Instance）"><a href="#材质实例（Meterial-Instance）" class="headerlink" title="材质实例（Meterial Instance）"></a>材质实例（Meterial Instance）</h3><p>上个模块我们提到不可以在运行时更改材质，这个特性会对当下的游戏开发带了不少的困扰，例如动态的游戏场景，而材质实例就是为了解决这个问题存在的。</p><p>材质实例是材质的特殊版本。它允许我们在游戏运行的时候修改材质中的参数和纹理而不需要重新编译材质，这让材质实例的迭代变得非常快，所以你几乎可以实时看到变化效果，你还可以通过时间轴和蓝图与材质实例进行交互。</p><p>当你使用单独的材质实例的时候，其性能优势很有限，而当你使用大量的材质实例而不是材质的时候他的性能优势就会逐渐显示出来。</p><p>材质实例非常的灵活，你可以设置一个主材质，然后在材质实例中设置许多的参数以便后期调整材质，而无需编写大量复杂的着色器代码（Shader Code）。</p><h3 id="主材质（Master-Material"><a href="#主材质（Master-Material" class="headerlink" title="主材质（Master Material)"></a>主材质（Master Material)</h3><p>主材质是一种用未完成许多任务的材质，可以在项目中满足对象的不同材质需求</p><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200515164106538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200515164117415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>左侧是Base_Color 可以使用取色器将材质设置成任意颜色</p><p>右侧是纹理参数节点，它允许我们在材质实例中添加任意纹理</p><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200515164341431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>标量参数，标量参数控制标量变量，允许我们更改材质实例中的参数，以便增加或者减少材质实例的某种效果</p><h4 id="主材质的注意事项"><a href="#主材质的注意事项" class="headerlink" title="主材质的注意事项"></a>主材质的注意事项</h4><p>不要尝试将一种主材质用于所有对象，它会让材质臃肿不堪，最终导致性能问题，可以所有的透明物体使用一种材质，所有的半透明使用一种，主角使用一种，武器使用一种。</p><h2 id="主材质的概念"><a href="#主材质的概念" class="headerlink" title="主材质的概念"></a>主材质的概念</h2><h3 id="材质函数（Material-Function）"><a href="#材质函数（Material-Function）" class="headerlink" title="材质函数（Material Function）"></a>材质函数（Material Function）</h3><p>材质函数允许你共享并复用材质图标的部分内容。UE4自带了诸多材质函数，比如确定场景对象的位置、鼠标在屏幕中位置等函数。你可以方便地将代码封装成材质函数，然后通过材质库分享代码。</p><p>材质函数允许你共享材质代码，从而在你调整全局效果时减少维护代码的麻烦</p><h3 id="RGB遮罩打包（RGB-Mask-Packing）"><a href="#RGB遮罩打包（RGB-Mask-Packing）" class="headerlink" title="RGB遮罩打包（RGB Mask Packing）"></a>RGB遮罩打包（RGB Mask Packing）</h3><p>将不同的纹理保存在同一张纹理的RGB通道中，能有效的减少纹理的占用量。</p><p>在使用RGB遮罩打包的时候要注明RGB通道中各自保存的纹理类型。</p><h3 id="静态开关-Static-switches"><a href="#静态开关-Static-switches" class="headerlink" title="静态开关 (Static switches)"></a>静态开关 (Static switches)</h3><p>他允许你启用或者禁用材质中的整条代码路径。<br>        <u>比如你可以将视差法线贴图放在静态开关内，因为其开销很大，所以可以只在需要的时候开启它就可以了。</u></p><h3 id="特性层级开关（Feature-Level-Switch）"><a href="#特性层级开关（Feature-Level-Switch）" class="headerlink" title="特性层级开关（Feature Level Switch）"></a>特性层级开关（Feature Level Switch）</h3><p>它可以让材质在任何目标设备上运行。</p><p><u>例如ES2：用于安卓等移动设备。SM5可以获得最高等级的精细度</u></p><h2 id="实践部分"><a href="#实践部分" class="headerlink" title="实践部分"></a>实践部分</h2><h3 id="主材质"><a href="#主材质" class="headerlink" title="主材质"></a>主材质</h3><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200515223946279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>简单讲一下 </p><p>在UE4中创建一个新的材质，完成相关的蓝图设计。</p><p>这张图创建的材质包括了底色（Base Color)，金属(Metallic)，粗糙程度(Roughness)，法线贴图(Normal) </p><p>在Base_color中有一个Swtich判断显示纹理还是显示取色器颜色。</p><p>Meallic中添加一个参数控制金属光泽</p><p>在Roughness中 lerp()函数为线性插值函数，能上调或调低粗糙度数值，先导入粗糙纹理，在纹理取样类型设置中改为“遮罩”并转换成参数，中间来获取遮罩参数，筛选纹理的RGB通道再连接至lerp函数中的阿尔法通道，通过两个参数的调节控制粗糙程度</p><p>导入法线贴图，将采样类型设置为法线。</p><p>完成主材质制作。 更名、分组对于后期管理很重要。</p><h4 id="改为玻璃对象的主材质"><a href="#改为玻璃对象的主材质" class="headerlink" title="改为玻璃对象的主材质"></a>改为玻璃对象的主材质</h4><p>玻璃的主要属性就是透明，然而我们发现现在主材质的Opacity属性是黑色的，即不可操作。而要打开这个参数我们需要将主材质的属性切换为Translucent，然后就会发现粗糙度相关的点变为了不可操作，而Opacity被打开了。我们按住1点击屏幕创建一个常量，将其链接到Opacity上，即可调整当前材质的透明度。</p><h3 id="材质函数"><a href="#材质函数" class="headerlink" title="材质函数"></a>材质函数</h3><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200516122149422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>创建材质函数，进入蓝图进行创建 <u>控制纹理缩放的材质函数</u></p><p>TexCoord[0]是贴图坐标系，它反映的是只坐标的变化。<br>        Input Texture_Scaling是一个输入节点，在这里我们用来表示坐标缩放的大小。<br>        Multiply是相乘的意思，即将坐标与缩放相乘获得最终的坐标，然后相乘的坐标作为输出结果</p><h4 id="材质函数的应用"><a href="#材质函数的应用" class="headerlink" title="材质函数的应用"></a>材质函数的应用</h4><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200516122727116.png" alt=""></p><p>将材质函数拖入主材质中，MF_Title 为拖入的材质函数，在左侧创建一个参数作为函数的输入，控制缩放的材质大小</p><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200516122852524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>将函数的输出与纹理、粗糙度等建立联系，输入位置为UVs</p><h3 id="材质实例"><a href="#材质实例" class="headerlink" title="材质实例"></a>材质实例</h3><p>材质实例和主材质具有父子关系，子类只能继承或使用父类拥有的属性。</p><h4 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h4><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200516153410274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>1.左侧，右键点击一个材质，在弹出的菜单中选择创建材质实例<br>        2.在内容浏览器的空白处右键可以在材质子菜单中找到材质实例</p><h4 id="材质实例的使用"><a href="#材质实例的使用" class="headerlink" title="材质实例的使用"></a>材质实例的使用</h4><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200516160627181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>可以看见他包含了我刚才创建的Base_Color、Metallic、Normal、Roughness。</p><p>Scalar Parameter Values中包含控制创建的材质函数输入值，相当于其他选项。（因为没有直接连接到主材质上</p><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200516214329317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>在通用字段下可以修改父材质的属性和函数。</p><p>【two sides】：双面。如果勾选中了这个属性，则材质将会双面渲染，双面指的是内面和外面。</p><p>【Dithered LODTransition】：颤化LOD过滤。它用于植被系统。（这个选项违背了父材质系统的初衷，因此请谨慎使用）</p><p>【Shading Model】：如果不想创建材质又想快速的看到效果可以使用这个东西。</p><h2 id="顶点动画"><a href="#顶点动画" class="headerlink" title="顶点动画"></a>顶点动画</h2><p>顶点动画以极低的开销实现复杂对象的微妙运动，如水面、树叶、布料等。顶点动画完全由GPU完成，完全不使用CPU。这使得每一帧的渲染开销都很低。</p><p>缺点是其互动性低，即CPU和我们所处理的逻辑无法获取到动画的偏移量。因此无法用于任何与游戏互动相关的部分，比如交互和碰撞。</p><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200516220152564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>在这颗植物中，只有叶子在随风飘摇，而树干则没有动态的效果。因此我们需要将叶子与树干分离，使用两个静态网格体或者使用两个不同的材质，如上图。其中TreeBark材质为静态的材质，而下面的CherryTree_Wind则是设置了顶点动画的材质。</p><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200516220525736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>其中上侧的TextureSample设置为Mask，将其RGB链接到BaseColor成为底色，而Alpha链接到OpacityMask上。同时拖入一张法线贴图，使其拥有法线效果。</p><p>这样一张静态的材质就做好了。</p><p>而动态的产生依赖于左边的3个模块，分别是两个常量和一个SimpleGrassWind效果，图中链接的3个常量点是必须要设置的参数，设置后将风模块链接到主材质的World Position Offset，即可将风的动态效果映射到世界坐标偏移上，从而产生动态的效果，注意选择双面。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UE4笔记（四）</title>
      <link href="/2020/07/16/%E8%99%9A%E5%B9%BB%E5%9B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2020/07/16/%E8%99%9A%E5%B9%BB%E5%9B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="UE4学习笔记（四）"><a href="#UE4学习笔记（四）" class="headerlink" title="UE4学习笔记（四）"></a>UE4学习笔记（四）</h1><h2 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h2><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>规范的命名可以节省大量的时间</p><p>例如：</p><p>SM_Rock_00  - Static Mesh for a Rock version 00  静态网格体的岩石   SM为静态网格体</p><p>T_Rock__00_BC - Base Color Texture for a Rock version 00  岩石的底色纹理 版本是“00” </p><p>SKM_RockBunch_00 - Skeletal Mesh for Rocks version 00  岩石的骨骼网格体 版本是“00”</p><p>_N 法线贴图</p><h3 id="纹理的创建"><a href="#纹理的创建" class="headerlink" title="纹理的创建"></a>纹理的创建</h3><p>纹理的长和宽必须始终是2的幂数（不一定为正方形 ),不规范的纹理无法进行多级渐进纹理，意味着无论摄像机离多远，它所占据的内存不变</p><h3 id="处理阿尔法信息"><a href="#处理阿尔法信息" class="headerlink" title="处理阿尔法信息"></a>处理阿尔法信息</h3><p>嵌入式或单独阿尔法通道</p><p>嵌入阿尔法开销是单独阿尔法的两倍，因为存储再这张纹理中的信息未经压缩就导入进虚幻引擎，意味着它被导入虚幻引擎后，你会得到纹理的完整分辨率</p><p>单独阿尔法的好处是 相对于底色尺寸，能单独控制阿尔法通道大小</p><h3 id="纹理保存和UE4支持的各种纹理格式"><a href="#纹理保存和UE4支持的各种纹理格式" class="headerlink" title="纹理保存和UE4支持的各种纹理格式"></a>纹理保存和UE4支持的各种纹理格式</h3><p>PNG PSD TGA 支持嵌入式阿尔法通道</p><p>BMP FLOAT IPG EXR DDS HDR</p><p>(HDR立方体贴图导入UE4用于光照时，纹理长宽不用是2的幂，唯一)</p><h3 id="多级渐进纹理"><a href="#多级渐进纹理" class="headerlink" title="多级渐进纹理"></a>多级渐进纹理</h3><p>可以将多级渐进纹理看作是纹理的细节层次，纹理被导入UE4后就会生成多级渐进纹理.</p><p><img src="https://s1.ax1x.com/2020/07/19/UWqaB8.png" alt=""><br>多级渐进纹理链  在Level of Deatail - LOD Bias 设置</p><p>假设纹理再屏幕上只占据了100或200个像素点或者离玩家有100米或200米远，我们没必要显示纹理的完整清晰度，在很多使用多级渐进纹理的项目中，你通常会看到第二级或者第三级的渐进纹理，这样可以减少内存消耗，只有当纹理占据当前屏幕很大一部分的时候，你才能看见第一级纹理。</p><h3 id="纹理组（Texture-Group"><a href="#纹理组（Texture-Group" class="headerlink" title="纹理组（Texture Group)"></a>纹理组（Texture Group)</h3><p>纹理组实际上控制着项目中渲染纹理的实际大小、还控制着纹理的缩放程度以及GPU会对纹理采用何种类型的纹理过滤</p><p>假如你发现项目的纹理内存不够用了，纹理组是一种很好的方式来一次性修改LOD偏差</p><p><a href="https://docs.unrealengine.com/zh-CN/Engine/Content/Types/Textures/SupportAndSettings/index.html" target="_blank" rel="noopener">纹理组的官方文档</a></p><h2 id="源控制（协同开发）"><a href="#源控制（协同开发）" class="headerlink" title="源控制（协同开发）"></a>源控制（协同开发）</h2><h3 id="源代码管理软件"><a href="#源代码管理软件" class="headerlink" title="源代码管理软件"></a>源代码管理软件</h3><p>用来存储、跟踪项目文件，并将其共享给其他希望一同开发的人员。</p><p>UE4最常用的是Perforce和Subversion 都能完成三点：</p><p>1.Sync Data (同步数据)</p><p>2.Add/Remove Data （添加删除数据)</p><p>3.Revert Data （恢复数据）</p><h2 id="静态网格体"><a href="#静态网格体" class="headerlink" title="静态网格体"></a>静态网格体</h2><h3 id="材质ID"><a href="#材质ID" class="headerlink" title="材质ID"></a>材质ID</h3><p>所有对象都至少拥有一个材质ID，材质ID有助于确定多边形面使用的材质类型，但对象每多用一个材质ID，他就需要被多渲染一次，例如一个物体上有五个材质ID，他就需要先被渲染五次然后通过一次最终渲染显示出来。</p><h3 id="光照贴图"><a href="#光照贴图" class="headerlink" title="光照贴图"></a>光照贴图</h3><p>光照贴图是专门用来保存光线和阴影复杂信息的纹理，这是因为纹理的开销很低，非常适合存储这类数据，并且将光照计算信息保存在纹理中意味着我们在运行的时候几乎能以零成本获得这些信息。</p><p><img src="https://s1.ax1x.com/2020/07/19/UWqtjP.md.png" alt=""></p><p>左侧为光照贴图，右侧为阴影贴图</p><p>1.光照贴图的RGB通道中存储着不同类型的数值，看起来像五颜六色的维诺图。是由不同的区域的光照信息写入RBG通道中造成的。</p><p>2.阴影贴图的红色和绿色表示不同的阴影信息，所有的阴影数据全部写入了阴影贴图的RGB通道</p><p>光照贴图需要对象上的每一张面都位于0到1的UV空间中，这些面在UV通道中不能相互重叠</p><p><a href="https://docs.unrealengine.com/zh-CN/Engine/Content/Types/StaticMeshes/HowTo/UVChannels/index.html" target="_blank" rel="noopener">使用UV通道的官方文档</a></p><p><a href="https://docs.unrealengine.com/zh-CN/Engine/Content/Types/StaticMeshes/AutoGeneratedLightmaps/index.html" target="_blank" rel="noopener">生成光照贴图UV的官方文档</a></p><h3 id="碰撞"><a href="#碰撞" class="headerlink" title="碰撞"></a>碰撞</h3><p>两种方法进行创建</p><p>1.在DCC中进行创建然后把它和集合体一起导入</p><p>UCX_  碰撞盒命名  UCX _ (FullNameOfMesh) _ Number  在DCC中命名后选择导出FBX，导入UE4中系统会自动根据UCX_将他更改为碰撞盒</p><p>2.在虚幻引擎内进行创建</p><p>（窗口）凸分解可以为不规则物体创建碰撞参数</p><h4 id="过度绘制"><a href="#过度绘制" class="headerlink" title="过度绘制"></a>过度绘制</h4><p>当你处理透明或不透明材质时，会出现过度绘制，他表示许多透明纹理相互重叠时GPU必须重复绘制这些纹理。过度绘制没法彻底消除，只能限制它，多用于植被。</p><h3 id="LOD"><a href="#LOD" class="headerlink" title="LOD"></a>LOD</h3><p>表示”细节层次”，相当于模型的副本，只是三角面数量减少了，有时材质指令的数量也会减小</p><p>如果模型只占屏幕中一两百个像素时，就没有必要显示它的所有面，更好的办法是显示一个分辨率更低的但轮廓相同的模型，只有标准模型一半数量的顶点，从而达到减小内存的方式，在开发VR应用时这点尤为重要，模型都应具备某些细节层次，你可以设置随意数量的细节层次，但超过一定数量后，它实际上就会对你的项目不利。</p><p>网格体面数的缩减量通常应该减少75%、35%最后是12%。</p>]]></content>
      
      
      
        <tags>
            
            <tag> UE4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4笔记（三）</title>
      <link href="/2020/07/12/%E8%99%9A%E5%B9%BB%E5%9B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2020/07/12/%E8%99%9A%E5%B9%BB%E5%9B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="UE4学习笔记（三）"><a href="#UE4学习笔记（三）" class="headerlink" title="UE4学习笔记（三）"></a>UE4学习笔记（三）</h1><h2 id="关于蓝图的概念"><a href="#关于蓝图的概念" class="headerlink" title="关于蓝图的概念"></a>关于蓝图的概念</h2><p>虚幻引擎中的蓝图-<u>可视化脚本系统</u>，可视化意味着将代码变成了一个个可见的模块，蓝图就是封装了很多现成的逻辑，它方便了基础系统的创建和逻辑的工程化分层。小型游戏完全可以使用蓝图制作。</p><p>UE4推出的蓝图系统，更深的意义是帮助设计人员快速设计原型，完成与程序开发人员的交流。</p><h3 id="组件概念"><a href="#组件概念" class="headerlink" title="组件概念"></a>组件概念</h3><p>是可添加到Actor的一项功能，组件不可独立存在，但在将其添加到Actor后，该Actor便可以访问并可以使用该组件所提供的功能。</p><p>一旦添加了用于定义 Actor 的组件，请注意，即使不提供任何 <strong>Blueprint</strong> 脚本（或 C++ 代码）也可将 Actor 放置在关卡中，就像汽车一样（在真实世界中，汽车本身就是一个物体，无需驾驶员告诉汽车该做什么）。 由于“油门踏板”是一个组件，通过脚本或代码，您可表示已踩下了踏板，从而为汽车加速提供了逻辑。 可以此种方式访问每个组件（打开车灯、按喇叭、开启收音机、转动方向盘等）</p><p><u>在这里写到一半的时候，发现自己基础知识掌握不牢固 很多术语不会，所以搁浅了蓝图的学习，重新开始学习整个引擎的构造基础，大概时长为两周。</u></p><h2 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h2><h6 id="在虚幻引擎中，何谓Actor？"><a href="#在虚幻引擎中，何谓Actor？" class="headerlink" title="在虚幻引擎中，何谓Actor？"></a>在虚幻引擎中，何谓Actor？</h6><p>一个或多个组件共同作为单一实体来运行</p><h6 id="有一个大规模团队，并且希望加速资源的共享。您可以做些什么来帮助共享美术资源？"><a href="#有一个大规模团队，并且希望加速资源的共享。您可以做些什么来帮助共享美术资源？" class="headerlink" title="有一个大规模团队，并且希望加速资源的共享。您可以做些什么来帮助共享美术资源？"></a>有一个大规模团队，并且希望加速资源的共享。您可以做些什么来帮助共享美术资源？</h6><p>与团队成员共享衍生数据缓存</p><h6 id="将项目移动到一个虚幻引擎的新预览版本时，您收到一条消息，提示插件不受支持。如何绕过此问题并启动您的项目？"><a href="#将项目移动到一个虚幻引擎的新预览版本时，您收到一条消息，提示插件不受支持。如何绕过此问题并启动您的项目？" class="headerlink" title="将项目移动到一个虚幻引擎的新预览版本时，您收到一条消息，提示插件不受支持。如何绕过此问题并启动您的项目？"></a>将项目移动到一个虚幻引擎的新预览版本时，您收到一条消息，提示插件不受支持。如何绕过此问题并启动您的项目？</h6><p>从.uproject文件中移除插件</p><h6 id="想要将蓝图项目发送给另一名开发者。该开发者需要-uproject文件以及哪些必需文件夹才能运行该项目？"><a href="#想要将蓝图项目发送给另一名开发者。该开发者需要-uproject文件以及哪些必需文件夹才能运行该项目？" class="headerlink" title="想要将蓝图项目发送给另一名开发者。该开发者需要.uproject文件以及哪些必需文件夹才能运行该项目？"></a>想要将蓝图项目发送给另一名开发者。该开发者需要.uproject文件以及哪些必需文件夹才能运行该项目？</h6><p>Content和Config文件夹</p><h6 id="想要覆盖游戏模式，使之应用于整个项目。需要在哪里操作才能实现？"><a href="#想要覆盖游戏模式，使之应用于整个项目。需要在哪里操作才能实现？" class="headerlink" title="想要覆盖游戏模式，使之应用于整个项目。需要在哪里操作才能实现？"></a>想要覆盖游戏模式，使之应用于整个项目。需要在哪里操作才能实现？</h6><p>项目设置</p><h6 id="项目菜单上有一个关卡需要使用单独的游戏模式。会在编辑器的什么地方设置该游戏模式？"><a href="#项目菜单上有一个关卡需要使用单独的游戏模式。会在编辑器的什么地方设置该游戏模式？" class="headerlink" title="项目菜单上有一个关卡需要使用单独的游戏模式。会在编辑器的什么地方设置该游戏模式？"></a>项目菜单上有一个关卡需要使用单独的游戏模式。会在编辑器的什么地方设置该游戏模式？</h6><p>世界场景设置</p><h6 id="将项目设置为当启动编辑器时就会加载贴图文件。可以在“项目设置”中执行此修改吗？"><a href="#将项目设置为当启动编辑器时就会加载贴图文件。可以在“项目设置”中执行此修改吗？" class="headerlink" title="将项目设置为当启动编辑器时就会加载贴图文件。可以在“项目设置”中执行此修改吗？"></a>将项目设置为当启动编辑器时就会加载贴图文件。可以在“项目设置”中执行此修改吗？</h6><p>可以，贴图设置和模式设置就在这里。</p><h6 id="在开发过程中，你决定要添加平台。在哪里可以方便地为项目添加平台？"><a href="#在开发过程中，你决定要添加平台。在哪里可以方便地为项目添加平台？" class="headerlink" title="在开发过程中，你决定要添加平台。在哪里可以方便地为项目添加平台？"></a>在开发过程中，你决定要添加平台。在哪里可以方便地为项目添加平台？</h6><p>项目设置</p><h6 id="场景中有一种粒子效果只在游戏视图下查看时才运行。想要看到这种粒子效果运行，最快的方法是什么？"><a href="#场景中有一种粒子效果只在游戏视图下查看时才运行。想要看到这种粒子效果运行，最快的方法是什么？" class="headerlink" title="场景中有一种粒子效果只在游戏视图下查看时才运行。想要看到这种粒子效果运行，最快的方法是什么？"></a>场景中有一种粒子效果只在游戏视图下查看时才运行。想要看到这种粒子效果运行，最快的方法是什么？</h6><p>按 G 键启用游戏视图（Game View）。</p><p>其它方法</p><p>1.进入“在编辑器中运行（Play in Editor）”模式。</p><p>2.以独立窗口启动游戏。</p><p>3.模拟游戏。</p><h6 id="构建了一个场景，想要从多个预设的角度快速查看它。使用哪个虚幻引擎快捷方式效果最好？"><a href="#构建了一个场景，想要从多个预设的角度快速查看它。使用哪个虚幻引擎快捷方式效果最好？" class="headerlink" title="构建了一个场景，想要从多个预设的角度快速查看它。使用哪个虚幻引擎快捷方式效果最好？"></a>构建了一个场景，想要从多个预设的角度快速查看它。使用哪个虚幻引擎快捷方式效果最好？</h6><p>书签</p><h6 id="优化C盘空间"><a href="#优化C盘空间" class="headerlink" title="优化C盘空间"></a>优化C盘空间</h6><p>1.在epic中的设置 将保管库的位置移到C盘外</p><p>2.缓存位置转移</p><p><a href="https://blog.csdn.net/cc13813194235/article/details/53424866" target="_blank" rel="noopener">CSDN方法</a></p><h6 id="创建了一个基于蓝图的可移植项目。为什么可以将其更改为基于台式机且可使用C-代码的项目？"><a href="#创建了一个基于蓝图的可移植项目。为什么可以将其更改为基于台式机且可使用C-代码的项目？" class="headerlink" title="创建了一个基于蓝图的可移植项目。为什么可以将其更改为基于台式机且可使用C++代码的项目？"></a>创建了一个基于蓝图的可移植项目。为什么可以将其更改为基于台式机且可使用C++代码的项目？</h6><p>初始项目创建是默认设置，而非永久设置。</p><h6 id="为何应在项目设置中设置目标平台？"><a href="#为何应在项目设置中设置目标平台？" class="headerlink" title="为何应在项目设置中设置目标平台？"></a>为何应在项目设置中设置目标平台？</h6><p>设置您的目标平台将禁用非必要的设置</p>]]></content>
      
      
      
        <tags>
            
            <tag> UE4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4笔记（二）</title>
      <link href="/2020/07/04/%E8%99%9A%E5%B9%BB%E5%9B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/07/04/%E8%99%9A%E5%B9%BB%E5%9B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="UE4学习笔记（二）"><a href="#UE4学习笔记（二）" class="headerlink" title="UE4学习笔记（二）"></a>UE4学习笔记（二）</h1><h2 id="关于光照重建问题的解决方法"><a href="#关于光照重建问题的解决方法" class="headerlink" title="关于光照重建问题的解决方法"></a>关于光照重建问题的解决方法</h2><p>有两种解决方法。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>点击构建中的仅构建光照(三角中）。<img src="https://img-blog.csdnimg.cn/20200301164635423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fsenp3,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>右侧搜索light，在光照的变换中将固定改为可移动。</p><p><img src="https://img-blog.csdnimg.cn/20200217135620377.png" alt=""></p><h3 id="光源的移动性差别："><a href="#光源的移动性差别：" class="headerlink" title="光源的移动性差别："></a>光源的移动性差别：</h3><p><strong>Stationary:</strong></p><p>固定光源是保持固定位置不变的光源，但你可以改变光源的亮度和颜色等。这是与静态光源的主要不同之处，静态光源在gameplay期间不会改变。但是，如果在运行时更改亮度，请注意它仅影响直接光照。间接（反射）光照不会改变，因为它是在光照系统（Lightmass）中预先计算的。</p><p><strong>Mobile:</strong></p><p>可移动光源使用完全动态的光照，一切都可以在游戏中改变，但其性能消耗极大，通常而言与光源影响的范围成正比（投射完全动态的光照和阴影。可修改位置、旋转、颜色、亮度、衰减、半径等所有属性。其投射的光照不会烘焙到光照贴图中，在无全局光照方法时不支持间接光照。）</p><p><strong>Static:</strong></p><p>在运行时完全无法更改或移动的光源。这些光源仅在光照贴图中计算，一旦处理完，对性能没有进一步影响。可移动对象不能与静态光源集成，因此静态光源的用途是有限的。</p><p>静态照明仅使用光照贴图，因此它们的阴影会在游戏前烘焙。这意味着，它们不能让移动（动态）对象产生阴影。如果要照明的对象也是静态的，就能够产生面积（接触）阴影。</p><p>主要应用对象是移动平台上的低性能设备。</p><p><img src="https://img-blog.csdnimg.cn/20200217135623122.png" alt=""></p><p><a href="https://docs.unrealengine.com/zh-CN/Engine/Rendering/LightingAndShadows/LightMobility/index.html" target="_blank" rel="noopener">关于光源移动性的具体文档</a></p><h2 id="Landscape室外地形创建（并使用第三人称游戏模式游玩）"><a href="#Landscape室外地形创建（并使用第三人称游戏模式游玩）" class="headerlink" title="Landscape室外地形创建（并使用第三人称游戏模式游玩）"></a>Landscape室外地形创建（并使用第三人称游戏模式游玩）</h2><p>landscape能为世界场景创建地形山脉、山谷、起伏或倾斜的地面，甚至洞穴的开口并通过一系列工具轻松修改其形状和外观</p><h3 id="打开地形工具方法"><a href="#打开地形工具方法" class="headerlink" title="打开地形工具方法"></a>打开地形工具方法</h3><p>1.在模式中选中landscape （快捷键为shift+2）</p><p><img src="https://docs.unrealengine.com/Images/Engine/Landscape/Landscape_Modes.webp" alt=""></p><p>2.在放置actors中的all classes（所有类中）选择地形landscape或通过搜索</p><h3 id="地形创建"><a href="#地形创建" class="headerlink" title="地形创建"></a>地形创建</h3><p>manage中导入你的地形材质创建基础地形大小，Sculpt（雕刻）中修改地形形状，Paint中修改部分地形外观。</p><p><img src="https://docs.unrealengine.com/Images/Engine/Landscape/Editing/Landscape_ManageMode.webp" alt=""></p><p><a href="https://docs.unrealengine.com/zh-CN/Engine/Landscape/QuickStart/3/index.html" target="_blank" rel="noopener">具体关于Sculpt工具使用方法</a></p><h4 id="灰度图和高度图"><a href="#灰度图和高度图" class="headerlink" title="灰度图和高度图"></a>灰度图和高度图</h4><p>在PS中，将高度图的模式改为灰度，16位通道，UE4的格式只支持.RAW和.PNG。</p><h3 id="植被的碰撞设置"><a href="#植被的碰撞设置" class="headerlink" title="植被的碰撞设置"></a>植被的碰撞设置</h3><p><a href="https://docs.unrealengine.com/zh-CN/Engine/Foliage/index.html" target="_blank" rel="noopener">笔刷使用方法</a></p><p>一开始用画笔刷上的物体是没有碰撞体积的。选中要加上碰撞的植物模型，先进入网格体界面，查看是否有简单碰撞，如果没有就用凸包分解创建碰撞模型（性能消耗大）或者直接用盒体等创建。模型碰撞完成之后，进入外部的碰撞预设，改为BlockAll或其他碰撞方式。</p><h3 id="关于官方第三人称模型的使用方法"><a href="#关于官方第三人称模型的使用方法" class="headerlink" title="关于官方第三人称模型的使用方法"></a>关于官方第三人称模型的使用方法</h3><p>两种方式实现。</p><h4 id="1添加第三人称标准模块"><a href="#1添加第三人称标准模块" class="headerlink" title="1添加第三人称标准模块"></a>1添加第三人称标准模块</h4><p>在ThirdPersonBP中选择Character加入场景。点击人体模型，在细节中选择ThirdPersonCharacter（自身）搜索possess,在Pawn中自动控制玩家设为玩家0。</p><h4 id="2游戏模式设置"><a href="#2游戏模式设置" class="headerlink" title="2游戏模式设置"></a>2游戏模式设置</h4><p>在actor中搜索玩家出生点，放置在建立好的世界中。</p><p>打开世界场景设置</p><p>在Game Mode中建立游戏模式，例如第三人称游戏模式或者第一人称。</p><p>在Default Pawn Class中选择操控人物</p><h2 id="项目实现中其他遇到的问题"><a href="#项目实现中其他遇到的问题" class="headerlink" title="项目实现中其他遇到的问题"></a>项目实现中其他遇到的问题</h2><p>我建议看文档 ^_^</p>]]></content>
      
      
      
        <tags>
            
            <tag> UE4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4笔记（一）</title>
      <link href="/2020/07/01/%E8%99%9A%E5%B9%BB4%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/07/01/%E8%99%9A%E5%B9%BB4%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="UE4学习笔记（一）"><a href="#UE4学习笔记（一）" class="headerlink" title="UE4学习笔记（一）"></a>UE4学习笔记（一）</h1><p><a href="https://docs.unrealengine.com/zh-CN/index.html" target="_blank" rel="noopener">UE4官方文档</a>  </p><h2 id="界面系统"><a href="#界面系统" class="headerlink" title="界面系统"></a>界面系统</h2><p><img src="https://docs.unrealengine.com/Images/Engine/UI/LevelEditor/DefaultInterface_Windows.jp2" alt="">  </p><ul><li><ol><li>选卡栏和菜单栏  </li></ol></li><li><ol start="2"><li>工具栏  </li></ol></li><li><ol start="3"><li>模式  </li></ol></li><li><ol start="4"><li>内容浏览器  </li></ol></li><li><ol start="5"><li>视口  </li></ol></li><li><ol start="6"><li>世界大纲视图  </li></ol></li><li><ol start="7"><li>详细信息   </li></ol></li></ul><hr><h3 id="选卡栏"><a href="#选卡栏" class="headerlink" title="选卡栏"></a>选卡栏</h3><p>关卡编辑器的顶部有一个选卡，提供了当前正在编辑器的关卡的名称。其他编辑器窗口的选卡可以停靠在该选卡的旁边，以便快速地、方便地进行导航，这和网页浏览器类似。<br><img src="https://docs.unrealengine.com/Images/Engine/UI/LevelEditor/TabBar.jp2" alt=""><br>选卡名称本身将会反应出当前正在编辑的是哪个关卡。这种方式在整个编辑器中都是一致的 - 以当前正在编辑的资源命名编辑器选卡。<br>选卡栏的右侧是当前项目的名称。 </p><hr><h3 id="菜单栏"><a href="#菜单栏" class="headerlink" title="菜单栏"></a>菜单栏</h3><p>它提供了对编辑器中处理关卡时所用通用工具和命令的访问权限。<br><img src="https://docs.unrealengine.com/Images/Engine/UI/LevelEditor/MenuBar/MenuBar_Windows.jp2" alt=""><br>该命令行控制台是个文本框，允许您输入编辑器可以识别的特殊控制台命令。该文本框有自动补全的功能，它可以自动列出和文本框中当前输入的文本匹配的所有命令.  </p><hr><h3 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h3><p><img src="https://docs.unrealengine.com/Images/Engine/UI/LevelEditor/Toolbar/toolbar.jp2" alt=""><br>这里提供了一组快速访问常用工具和操作的命令。  </p><hr><h3 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h3><p>Viewport（视口） 面板是进入到虚幻编辑器中创建的世界的窗口。<br><img src="https://docs.unrealengine.com/Images/Engine/UI/LevelEditor/Viewports/viewports_LE.jp2" alt=""><br>该面板包含了一组视口，每个视口都可以最大化,使其填充整个面板，且提供了在其中一种正交视图(顶视图、侧视图、前视图)或透视图显示世界的功能，使您可以充分地控制显示的内容及显示方式.  </p><hr><h3 id="详细信息"><a href="#详细信息" class="headerlink" title="详细信息"></a>详细信息</h3><p><img src="https://docs.unrealengine.com/Images/Engine/UI/LevelEditor/Details/details_panel.jp2" alt=""><br>包含了关于视口中当前选中对象的信息、工具及功能。它包含了用于移动、旋转及缩放Actor的变换编辑框，显示了选中Actor的所有可编辑属性，并提供了和视口中选中Actor类型相关的其他编辑功能。比如，选中的Actor可以导出到FBX文件中，并可以转换为另一种兼容类型。”选项详情“面板还允许您查看这些选中的Actor所使用的材质（如果存在），并可以快速地打开它们进行编辑。  </p><hr><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>模式（Modes） 面板包含用于编辑器的各种工具模式的选择。这些模式针对特定任务更改关卡编辑器主要行为，例如将新资源放入世界场景、创建几何笔刷和体积、在网格体上绘图、生成植物以及塑造地形。<br><img src="https://docs.unrealengine.com/Images/Engine/UI/LevelEditor/Modes/LE_Tools2.jp2" alt="">  </p><ul><li>TIP:<br>  您可以通过点击选卡右上角的小 “X” 来关闭任何面板。您也可以通过右击面板，然后在弹出的关联菜单中点击 Hide Tab（隐藏选卡），来隐藏任何面板。要想再次显示您已经关闭的面板，在 Window(窗口) 菜单中点击那个面板的名称即可。  </li></ul><p>模式 代表关卡编辑器可以处于的各种不同编辑模式，使得可以启用特定的编辑界面和工作流程来编辑特定类型的 Actor 或几何体  </p><hr><h3 id="世界大纲视图"><a href="#世界大纲视图" class="headerlink" title="世界大纲视图"></a>世界大纲视图</h3><p><img src="https://docs.unrealengine.com/Images/Engine/UI/LevelEditor/SceneOutliner/scene_outliner.jp2" alt=""><br>World Outliner（世界大纲视图） 面板以层次化的树状图形式显示了场景中的所有Actor。您可以从 世界大纲视图 中直接选择及修改Actor。您也可以使用 Info(信息) 下拉列表来打开额外的竖栏来显示关卡、图层或ID名称。  </p><hr><h3 id="图层"><a href="#图层" class="headerlink" title="图层"></a>图层</h3><p>图层（Layers） 面板允许您组织关卡中的Actor<br><img src="https://docs.unrealengine.com/Images/Engine/UI/LevelEditor/Layers/LayerInfra.jp2" alt=""><br>图层提供了快速选择和控制相关Actor组可视性的能力。 您可以使用您的图层来快速整理一个场景， 只留下您正在处理的几何体和Actor。例如，您可能正在处理一个由多个模块组成的 多层建筑。通过将每个楼层分配到一个图层，您可以隐藏您不在处理的每个楼层， 使顶视图更易于管理。 </p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> UE4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于博客文档语法 markdown 记录</title>
      <link href="/2020/06/03/Markdown/"/>
      <url>/2020/06/03/Markdown/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown-用法及注意事项"><a href="#Markdown-用法及注意事项" class="headerlink" title="Markdown 用法及注意事项"></a>Markdown 用法及注意事项</h1><p>我使用的是VS Code<br>另外Typora也挺好用的 都是轻量级编辑器  </p><h2 id="标题使用"><a href="#标题使用" class="headerlink" title="标题使用"></a>标题使用</h2><p> #一级标题<br> ##二级标题<br> ###三级标题<br> 总共六级标题 # 后由空格隔开 </p><hr><h2 id="有序列表和无序列表使用"><a href="#有序列表和无序列表使用" class="headerlink" title="有序列表和无序列表使用"></a>有序列表和无序列表使用</h2><p>有序直接在文字前加1.2.3.符号要和文字之间加上一个字符的空格<br>无序只需在文字前加-或者<em>&emsp;例如：</em> 1 </p><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p>只需要在文本前加入&gt;即可</p></blockquote><hr><h2 id="图片和超链接"><a href="#图片和超链接" class="headerlink" title="图片和超链接"></a>图片和超链接</h2><ul><li>图片为&emsp;：! [ ] ( )  </li><li>超连接为：[ ] ( )<br>方括号中为超链接名称，圆括号中输入网页，进行跳转<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=4012795741,2339581335&fm=26&gp=0.jpg" alt="ue4">  </li></ul><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p><a href="https://www.bilibili.com/" target="_blank" rel="noopener">B站地址</a>  </p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="Markdown/0.png" alt="">  </p><ul><li>将文件夹放在.md文档中，能在博客中直接上传本地图片</li></ul><hr><h2 id="粗体、斜体"><a href="#粗体、斜体" class="headerlink" title="粗体、斜体"></a>粗体、斜体</h2><p><strong>粗体</strong> &emsp;用两个 <em>* 包含文本<br>*斜体</em> &emsp;用一个 * 包含文本<br><strong><em>粗斜体</em></strong> &emsp;用三个 *** 包含文本<br><del>删除线</del> &emsp;用两个 ~~ 包含文本</p><hr><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><blockquote><table><thead><tr><th>性别</th><th align="center">年龄</th><th align="right">职业情况</th></tr></thead><tbody><tr><td>男</td><td align="center">16</td><td align="right">学生</td></tr><tr><td>女</td><td align="center">17</td><td align="right">学生</td></tr><tr><td>男</td><td align="center">18</td><td align="right">学生</td></tr></tbody></table></blockquote><p>效果<br>| 性别        | 年龄           | 职业情况  |<br>| —- |:———:| —–:|<br>| 男      | 16 | 学生 |<br>| 女      | 17      |   学生 |<br>| 男      | 18      |    学生 |<br>默认左对齐 第二行为分割线<br>剧中在两边加：右对齐只在右边加：上文的年龄和职业 </p><hr><h2 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h2><p>用两个` 把代码包裹起来 例如  </p><p><code>cout&lt;&lt;&quot;hello world&quot;</code><br>用三个` 把代码包裹起来 例如</p><pre class=" language-C++"><code class="language-C++">cout<<"hello world"</code></pre><p>在```C++可实现代码高光</p><hr><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p>分割线 三个*  </p></li><li><p>插入一个空格 (non-breaking space)<br>&amp;nbsp； 或    &amp;#160；     或      &amp;#xA0；</p><p>插入两个空格 (en space)<br>&amp;ensp；     或    &amp;#8194；   或      &amp;#x2002；</p><p>插入四个空格 (em space)<br>&amp;emsp；    或    &amp;#8195；   或      &amp;#x2003；</p><p>插入细空格 (thin space)<br>&amp;thinsp；   或     &amp;#8201；  或      &amp;#x2009；</p><p> 注意：不要漏掉分号。    </p></li></ul><hr><p>以后遇到问题会更改博客内容  </p><p><a href="https://blog.csdn.net/witnessai1/article/details/52551362" target="_blank" rel="noopener">Markdown 完整语法</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
