<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于第三人称魂类游戏个人学习--（1）</title>
      <link href="/2020/09/20/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0%E8%AE%A1%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/09/20/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0%E8%AE%A1%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="关于第三人称魂类游戏个人学习–（1）"><a href="#关于第三人称魂类游戏个人学习–（1）" class="headerlink" title="关于第三人称魂类游戏个人学习–（1）"></a>关于第三人称魂类游戏个人学习–（1）</h1><h3 id="创建场景光源-1"><a href="#创建场景光源-1" class="headerlink" title="创建场景光源(1)"></a>创建场景光源(1)</h3><p>所需组件：</p><p>Fog、skylight、DirectionalLight、Sky_Sphere</p><p>添加cube作为地板</p><p><img src="https://s1.ax1x.com/2020/09/20/w7JsmV.md.png" alt="1"></p><p>材质纹理大小可根据Texcoord进行调整。</p><h3 id="Mycharacter蓝图（1）"><a href="#Mycharacter蓝图（1）" class="headerlink" title="Mycharacter蓝图（1）"></a>Mycharacter蓝图（1）</h3><h4 id="实现角色基础操作"><a href="#实现角色基础操作" class="headerlink" title="实现角色基础操作"></a>实现角色基础操作</h4><p>创建GameMode蓝图，character蓝图。</p><p><img src="https://s1.ax1x.com/2020/09/20/w7J0ln.md.png" alt="2"></p><p>打开project setting在input中设置WASD和视口移动。X Roll、Y Pitch、Z Yaw</p><ul><li><p>UE4按照ZXY轴顺序（C++中）计算物体朝向</p></li><li><p>UE4使用左手坐标系。</p></li><li><p>Z轴旋转的正方向遵循左手定则，X轴和Y轴旋转的正方向遵循右手定则</p></li></ul><p>避免视角朝下速度减慢，使用矢量的分量</p><p><a href="https://en.wikipedia.org/wiki/Euler_angles#Proper_Euler_angles" target="_blank" rel="noopener">关于欧拉角的维基百科</a></p><p>给人物蓝图中加Mesh和Camera，摄像机臂可以在有物体挡住时向前透过物体的作用。</p><ul><li>SpringArm 中 Use Pawn Control Rotation 解决视口不能移动的问题</li></ul><p><img src="https://s1.ax1x.com/2020/09/20/w7JDO0.md.png" alt="3"></p><h3 id="Character蓝图（1）"><a href="#Character蓝图（1）" class="headerlink" title="Character蓝图（1）"></a>Character蓝图（1）</h3><h4 id="ABP、ABS创建"><a href="#ABP、ABS创建" class="headerlink" title="ABP、ABS创建"></a>ABP、ABS创建</h4><p>创建ABP_Mycharacter和ABS_Mycharacter（动画蓝图和混合空间）</p><p><img src="https://s1.ax1x.com/2020/09/20/w7JByq.md.png" alt="4"></p><p>水平坐标设为Direction，垂直坐标为Speed。ABS水平坐标分8格，8个角度使用不同的动作让人物往不同方向进行移动，速度为0时idle，速度最大值参照CharacterMovement所继承的最大行走速度。</p><p><img src="https://s1.ax1x.com/2020/09/20/w7JaWj.png" alt="5"></p><p>在ABP中应用ABS，用变量通过蓝图逻辑去获取Speed、Direction</p><p><img src="https://s1.ax1x.com/2020/09/20/w7JywT.md.png" alt="6"></p><p>事件蓝图更新动画：每帧检测动画有没有需要发生的变化。</p><hr><ul><li><p>Mesh中要绑定相应的ABP</p></li><li><p>欧拉角</p></li><li><p>创建ABP时注意骨骼的选用（ABS也要选择同样的骨骼）</p></li><li><p>动画蓝图不能使用get player controller/character</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> UE4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解析官方的蓝图场景之提示卡</title>
      <link href="/2020/08/05/%E8%A7%A3%E6%9E%90%E5%AE%98%E6%96%B9%E7%9A%84%E8%93%9D%E5%9B%BE%E5%9C%BA%E6%99%AF%E4%B9%8B%E6%8F%90%E7%A4%BA%E5%8D%A1/"/>
      <url>/2020/08/05/%E8%A7%A3%E6%9E%90%E5%AE%98%E6%96%B9%E7%9A%84%E8%93%9D%E5%9B%BE%E5%9C%BA%E6%99%AF%E4%B9%8B%E6%8F%90%E7%A4%BA%E5%8D%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="解析官方的蓝图场景之提示卡"><a href="#解析官方的蓝图场景之提示卡" class="headerlink" title="解析官方的蓝图场景之提示卡"></a>解析官方的蓝图场景之提示卡</h1><p>咳咳，写的时候顺序有点问题，我是先分析的事件图表，分析到第三个Box的for loop时，再把构造函数分析完，再继续的。。。</p><h2 id="提示卡"><a href="#提示卡" class="headerlink" title="提示卡"></a>提示卡</h2><p><img src="https://s1.ax1x.com/2020/08/05/aDXZkD.png" alt=""></p><p>一个评论提示框，其在玩家进入特定半径后便会打开。从一个距离进行查看时，物体看起来像是一个漂浮的圆盘，中间有一个”i”。玩家处于范围中时，圆盘将上下颠倒，显示为一个感叹号”！”，文本也将从其中扩展出来。此框固定朝向玩家。</p><p><img src="https://s1.ax1x.com/2020/08/05/aDXmfH.md.png" alt=""></p><p>打开蓝图</p><p><img src="https://s1.ax1x.com/2020/08/05/aDXM6I.md.png" alt=""></p><p>拆分组件</p><p><img src="https://s1.ax1x.com/2020/08/05/aDXK1A.png" alt=""></p><p>一开始我以为是动画蓝图做出来的效果，结果只是Actor蓝图实现的打开动画，一共有10个静态网格体组件，一个粒子系统组件，一个接收器</p><p><img src="https://s1.ax1x.com/2020/08/05/aDXete.md.png" alt=""></p><p>只有一个构造脚本，大体思路从蓝图都可以看出来，可以从图中看出大体分为三个模块。一个控制提示卡的方向一直面朝Play，一个控制粒子效果，还有一个控制打开关闭，显示文字。</p><p>构造脚本是在外可视的。并不是你在脚本内写的全部东西在事件图表中就不写了</p><p>逐个分析：</p><h3 id="构造脚本"><a href="#构造脚本" class="headerlink" title="构造脚本"></a>构造脚本</h3><h4 id="建立触发器球体组件的大小"><a href="#建立触发器球体组件的大小" class="headerlink" title="建立触发器球体组件的大小"></a>建立触发器球体组件的大小</h4><p><img src="https://s1.ax1x.com/2020/08/05/aDXUpj.png" alt=""></p><p><strong>Set Relative Scale 3D</strong> (设置相对范围3D) 球体碰撞范围接Target表明改变的为球体碰撞Volume，通过Get RrlativeScale3D得到Trigger矢量，与可设置变量float相乘得到新的球体碰撞范围。</p><h4 id="追踪使用的行数，然后获取最长行的长度"><a href="#追踪使用的行数，然后获取最长行的长度" class="headerlink" title="追踪使用的行数，然后获取最长行的长度"></a>追踪使用的行数，然后获取最长行的长度</h4><p>首先，观察蓝图，发现没有文本组件，观察了细节面板法线用户需要通过Lines手动整理每行文本</p><p><img src="https://s1.ax1x.com/2020/08/05/aDX1nP.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/08/05/aDXdcn.md.png" alt=""></p><p>Lines为一个字符型的阵列，通过阵列Length计算用户添加了多少行文本（上图为9行）输入给Number Of Lines，进行for循环，循环次数按照行数-1（行数为9从0开始到8），通过循环获取最长行的长度</p><h4 id="如用户已启用Preview-Mode变量，则扩展评论框"><a href="#如用户已启用Preview-Mode变量，则扩展评论框" class="headerlink" title="如用户已启用Preview Mode变量，则扩展评论框"></a>如用户已启用Preview Mode变量，则扩展评论框</h4><p><img src="https://s1.ax1x.com/2020/08/05/aDXwXq.md.png" alt=""></p><p>检测浏览模式是否打开</p><p><strong>SetRelativeLocation</strong>(设置相对位置)相当于Info Icon组件在蓝图中的X 1.0 Y 0.0 Z -10.0的位置，如果没有在外启用浏览模式，Info Icon向下移动了10个单位</p><p>如果启用了浏览模式，位置不变，大小有轻微的改变</p><p>这里位置的移动是为了配合评论框的显示。</p><h4 id="缩放框并重调其位置以适应文本"><a href="#缩放框并重调其位置以适应文本" class="headerlink" title="缩放框并重调其位置以适应文本"></a>缩放框并重调其位置以适应文本</h4><p><img src="https://s1.ax1x.com/2020/08/05/aDXiOx.png" alt=""></p><p>background组件连接，用新的大小来适应在Line中输入的文本。</p><p><img src="https://s1.ax1x.com/2020/08/05/aDXETO.png" alt=""></p><p>红绿蓝分别代表了background的XYZ轴。</p><p>X轴似乎只决定了Background的厚度，可以不考虑所以拆分向量，然后考虑的就是如何规范框的长宽？</p><p>框的宽度是由Y轴决定的，宽度大小决定于Longest Line Length，这里蓝图是</p><p>Y = Longest Line Length * 0.9 + Longest Line Length * 0.9 * 边界宽度填充</p><p><img src="https://s1.ax1x.com/2020/08/05/aDXP61.png" alt=""></p><p>我的理解是，紫色为边框的左右，红色为Longest Line Length * 0.9 蓝色为后面一部分填充的值，红色应该是显示文本的Basic，这里的边界宽度填充是一个可以改变的变量，用户可以自行决定它的延长。</p><p>Z轴决定了Background的高度</p><p>Z = Number Of Lines * 2.5</p><p>后面的Top Border、Bottom Border只改变Y轴，Left Border、Right Border只改变Z轴就是为了更加贴合Background改变后长宽的紫色区域。</p><h4 id="创建必要的TextRenderComponents（文本渲染组件）"><a href="#创建必要的TextRenderComponents（文本渲染组件）" class="headerlink" title="创建必要的TextRenderComponents（文本渲染组件）"></a>创建必要的TextRenderComponents（文本渲染组件）</h4><p><img src="https://s1.ax1x.com/2020/08/05/aDXA0K.md.png" alt=""></p><p>进入循环。</p><p><strong>Get Socket Location</strong> ：这里获取Background的位置，输入要进行转换socket的或bone的名称，得到的矢量与Actor矢量相减，<strong>UnrotateVector</strong>返回向量A被旋转器B的逆旋转后的结果，拆分只取Y值</p><p>Z = X * -10 + Number Of Lines *5 +5   （X = 0 –  Number Of Lines -1）</p><p>创建的新变量 <strong>Make</strong> <strong>Transform **将位置，旋转和缩放的值给</strong>Add TextRenderComponents**，我认为做这些步骤的一切就是以为了让文字达到贴在Background上的效果。</p><p>上面一部分应该是每次循环索引行，查看是否有文字，有文字的话就通过Add TextRenderComponents进行渲染设置为文本。</p><p><img src="https://s1.ax1x.com/2020/08/05/aDXkm6.png" alt=""></p><p>这一块看了很久，大体的意思应该是这样的。以后有能力了再仔细分析一下。</p><h3 id="事件图表"><a href="#事件图表" class="headerlink" title="事件图表"></a>事件图表</h3><h4 id="提示卡的自动旋转面朝效果"><a href="#提示卡的自动旋转面朝效果" class="headerlink" title="提示卡的自动旋转面朝效果"></a>提示卡的自动旋转面朝效果</h4><p><img src="https://s1.ax1x.com/2020/08/05/aDXupd.md.png" alt=""></p><p>我先给节点排了下序。</p><p>虚幻引擎4有一个被称为“Tick”的事件，它产生于游戏的每一帧。例如，在一个运行在每秒60帧的游戏中，“Tick”事件会在每一秒产生60次。“Tick”事件提供了一个被称为“delta秒”的值，该值是自上一帧结束后的时间。使用事件“Tick”，我们可以精确控制在游戏中的蓝图的运动。</p><p>有个例子，例如你这个游戏是50帧，delta Seconds= 1 sec /50  = 0.2 sec ,接着你的Actor每1 sec移动100 cm的距离 速度为 100cm/sec（1虚幻单位等于1厘米  1 UU = 1 CM）X= speed * Delta Seconds = 2cm 可以得到你的Actor每帧将移动2 cm。达到精确控制蓝图的运动问题。</p><p>事件发生以后，先有一个If的分支判断是否有玩家，获取玩家摄像机管理器（Get Actor Camera Manager)，它默认的为Player Index 0，按世界大纲设置，然后得到摄像机位置输入Target（向量）并与XYZ做比较，如果没有位置，坐标轴都为0，右侧是一个矢量的比较，如果A！=B，返回True，表明有玩家，接着进行下一步。</p><p><strong>Find Look At Rotation</strong>（寻找查看旋转）该节点有两个Vector类型参数，在Find Look At Rotation节点上分别传入物体的Location和摄像机的Location，节点会计算返回一个从Start到Target需要调整的角度</p><p><strong>RInterp To</strong>能让物体调整角度的效果更有动感（不加的话会瞬间到达）。RInterp To这个节点实际上就是Rotation的一个插值的表述，该节点有四个参数，Current和Target分别表示当前角度和目的角度，DeltaTime为间隔时间，一般设置为我们计算机计算每帧的时间，Interp speed为调整的速度，越小速度越慢，一般调整为5左右效果比较好。再次输入当前Actor也就是提示卡的位置到Current，返回节点得到的调整角度连接到Target，这个时候可以看出，使用Tick事件可以快速刷新，几乎实时改变面朝方位。</p><p>最后将最新的Actor位置输入给提示卡，完成Smoothly地转动。</p><h4 id="游戏中粒子效果"><a href="#游戏中粒子效果" class="headerlink" title="游戏中粒子效果"></a>游戏中粒子效果</h4><p>粒子效果应该指的是在未靠近的时候出现的呈现波浪状态的提示。</p><p><img src="https://s1.ax1x.com/2020/08/05/aDXZkD.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/08/05/aDXQXt.png" alt=""></p><p>游戏开始时先检查用户设置中是否打开粒子系统，下面的Disable Particle和Preview Mode为变量，可以在外面的细节面板设置是否打开，如果效果和浏览模式都没被禁用，那么OR函数返回的为false（OR函数无论何时只要一个输入中出现了真，输出就是真），后接一个Not(输出与输入相反)，相当于将ture输入Set Active，然后接下后面的逻辑。</p><ul><li><u>XOR是OR的变体。仅当一个输入或者另一个输入是真，但不是两者都为真（既如果输入是不同的），它的输出才为真。</u></li></ul><p><strong>Set Active</strong> (设置激活) 设置组件是否是活动的，将脉冲效果组件接入Target控制粒子效果组件。</p><p><strong>Activate</strong>（激活）：Actor组件对象引用至目标激活</p><p>后面的if设置为如果你shift+F1开启管理员模式也可以选择是否打开Preview MODE和Disable Particle，通过返回为true关闭粒子系统。</p><p>*<em>DestroyComponent *</em>（销毁组件）移除粒子组件</p><h4 id="触发BOX"><a href="#触发BOX" class="headerlink" title="触发BOX"></a>触发BOX</h4><p><img src="https://s1.ax1x.com/2020/08/05/aDX878.md.png" alt=""></p><p>首先进入Trigger范围内检查是否打开了预览模式。</p><p><strong>Do Once</strong>(只执行一次) 我的理解是： 如果你设置一个动作，是靠“L”触发的，你开始游戏后按”L“触发了一次，就再也不会触发了，但是你可以根据Reset设定一个新的值“P“，你按了”P“后就可以重置为最初状态，又可以按一次”L“，而”Start Closed“为布尔类型的参数，如果你勾选则这个系统将直接变为不可触发状态。这里Do once做的工作应为打开浏览模式，然后在Volume范围内保持浏览模式不变。</p><p>不在Trigger范围内检查预览模式，进入序列函数（按顺序进行引脚）</p><p>第一个引脚</p><p>*<em>For Loop *</em>(for循环)该节点左边的按钮分别是循环计数的初始值和终止值，右边的Loop Body按钮是指该循环的循环体,也就是每次需要执行的代码.Index返回当前下标的值,Completed连接循环结束后的执行语句.</p><p>这里的for loop循环体的目的是先检查文字行数组中是否还有文字，LENGTH &gt; 0的话（仍有文字）返回为false，销毁数组中的每个文本行，完成循环后再次检查数组中是否有文字，有的话重置，没有直接执行下一步。</p><p>在EndOverlap中下一步应该就是将值全设为0，然后删除场景内的文本框，只留下感叹号。</p><p>相当于把BeginOverlap重置还原。所以下面只看BeginOVerlap的分支。</p><h4 id="玩家进入球体组件触发器体积后对框组件设置动画，使其缩放至正确的大小"><a href="#玩家进入球体组件触发器体积后对框组件设置动画，使其缩放至正确的大小" class="headerlink" title="玩家进入球体组件触发器体积后对框组件设置动画，使其缩放至正确的大小"></a>玩家进入球体组件触发器体积后对框组件设置动画，使其缩放至正确的大小</h4><p><img src="https://s1.ax1x.com/2020/08/05/aDXYtg.md.png" alt=""></p><p> <a href="https://docs.unrealengine.com/zh-CN/Engine/Blueprints/UserGuide/Timelines/index.html" target="_blank" rel="noopener">时间轴官方文档解释</a></p><p>这里Simple Curve时间轴达到了打开文本框的动画效果目的。</p><p><strong>Lerp</strong>（插值）一般与Timeline时间轴一起使用，<u>Alpha取值范围如果是浮点数0到1，当Alpha为0的时候返回的数值为A设置的值，当Alpha为1的时候，返回的数值为B设置的值。Alpha越靠近0返回值就越靠近A设置的值，Alpha越靠近1返回值就越靠近B设置的值。</u> 能使目标运动更平滑</p><p>这里的时间轴控制一个用于在框的折叠/展开状态混合的值，它的时间轴如下</p><p>V+ <u>添加新的向量轨道到时间轴，以对浮点向量值（例如旋转值或平移值）进行动画处理。</u></p><p>使用最后一个关键帧：可以帮助防止动画循环时被跳过</p><p><img src="https://s1.ax1x.com/2020/08/05/aDX30f.md.png" alt=""></p><p>这里设置为0.5s，为折叠/展开的时间，0代表进入了不在Trigger范围内，所以文本框大小很小且固定（隐藏），1代表了将文本框展开，根据实际的情况扩大Background和各个边</p><p><img src="https://s1.ax1x.com/2020/08/05/aDXJAS.md.png" alt=""></p><p>控制了Info Icon的位置，在0时 Z轴 -10，1时Z轴为 0，还控制了Info Icon的旋转角度，达到展开文本，感叹号旋转180度的目的。</p><p>direction输出枚举数据，指明了时间轴的当前播放方向。</p><h4 id="音乐组件"><a href="#音乐组件" class="headerlink" title="音乐组件"></a>音乐组件</h4><p><img src="https://s1.ax1x.com/2020/08/05/aDXthQ.md.png" alt=""></p><p>这很明显，当进入Trigger以后盒子打开，会播放音乐，同时脉冲效果停止，盒子没打开的时候只会激活脉冲效果。</p><h4 id="创建文本"><a href="#创建文本" class="headerlink" title="创建文本"></a>创建文本</h4><p><img src="https://s1.ax1x.com/2020/08/05/aDXa1s.md.png" alt=""></p><p>这和构造脚本哪里很相似了。</p><p>循环体写出了每一行的文字，然后将文字进行位置变动、旋转，达到印在Background上的效果。</p><p>这和构造函数的区别是，构造函数是在外面的预览模式显示文本，然后这里是进入游戏后显示。</p><p>结束。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分析蓝图的好处还是很大的</p>]]></content>
      
      
      
        <tags>
            
            <tag> UE4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4笔记（十）</title>
      <link href="/2020/08/02/%E8%99%9A%E5%B9%BB%E5%9B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89/"/>
      <url>/2020/08/02/%E8%99%9A%E5%B9%BB%E5%9B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="UE4笔记（十）"><a href="#UE4笔记（十）" class="headerlink" title="UE4笔记（十）"></a>UE4笔记（十）</h1><p>首先这是蓝图概念的笔记，上一次是蓝图的整体内部构成原理的入门，按照我现在需要的工程，我觉得先看蓝图概念的内容，后面结合C++一起看蓝图的内部组成比较好。</p><h2 id="蓝图"><a href="#蓝图" class="headerlink" title="蓝图"></a>蓝图</h2><p>Blueprint is <strong>Visual  Scripting</strong> (you are programming!)</p><p>蓝图相当于游戏内容的容器，它们包含了许多基本单元，我们称之为“组件”         (汽车的例子)</p><ul><li>They can hold Components</li><li>They can hold script,but dont have to</li><li>They can hold Only data</li></ul><p>蓝图的本质是 将不同功能的节点链接在一起，编译之后能立马看到效果</p><p><u>Works by stringing together nodes and connections and see results instantly</u></p><p>Types of Blueprints: （大致上只有两种 关卡蓝图、类蓝图）</p><ol><li>Level Blueprint - One Per Level</li><li>Class Blueprint - Multiple（Modular）</li></ol><p>需要多次重复使用某个蓝图，但是需要更改其功能中的多个次要部分。相较于每次都重新创建蓝图，采用哪种做法更为合适呢？</p><ul><li>将新Actor作为子蓝图（继承及蓝图从父蓝图继承属性的功能）</li></ul><h3 id="蓝图编辑器UI"><a href="#蓝图编辑器UI" class="headerlink" title="蓝图编辑器UI"></a>蓝图编辑器UI</h3><p>创建一个Actor蓝图类</p><p><img src="https://s1.ax1x.com/2020/08/03/aN8ec6.md.png" alt=""></p><p>左上角为组件，允许我们添加各类组件，组件是蓝图的基本单元，内涵音效、粒子特效、骨骼或者静态网格体、摄像机</p><p>组件内置现成功能供使用、组件是构成蓝图的基本单元，还附有允许我们访问的功能或属性</p><p>顶部是主工具栏，找到允许我们找到任何引用该蓝图的对象，查找为找到当前蓝图位置，类设置允许我们定义一些特定的设置，类默认设置也一样，用来设置该蓝图的默认属性，调试过滤器允许我们调试蓝图的不同实例，假设关卡中有多个光源蓝图，而我们只希望调试其中一个，我们可以选择任意一个进行调试。</p><p>右侧为细节面板，定义和调整所有属性</p><p><img src="https://s1.ax1x.com/2020/08/03/aN8V91.png" alt=""></p><p>视口是基本选项还有构造脚本和事件图表</p><p>构造脚本的基本作用是允许我们设置该蓝图的自定义参数或者预设 相当于写一个函数</p><p><img src="https://s1.ax1x.com/2020/08/03/aN8Z1x.md.png" alt=""></p><p>事件图表用于在运行时更新蓝图脚本，当应用程序运行时，大部分需要执行的脚本可能都位于这里，脚本在这会逐步被执行</p><p>左侧的我的蓝图包含了所有图表、以及所有创建的函数（构造脚本），你还可以创建宏，创建并指定变量，事件分发器允许不同蓝图进行通信。</p><p><img src="https://s1.ax1x.com/2020/08/03/aN8mjK.png" alt=""></p><p>在蓝图的其他选项中</p><p>蓝图函数库是函数的集合，允许你通过其他蓝图访问它</p><p>蓝图接口是另一种通信工具，允许不同蓝图进行通信</p><p>蓝图宏库类似于函数库，它是宏的集合，允许你在不同蓝图中使用</p><p>枚举就是一种参数列表，你可以在蓝图中将他用于流控制（例如你可以将角色状态设置为枚举类型，所谓角色状态，可能是活着、死亡或者受伤，然后基于不同的状态在蓝图中切换执行不同的逻辑）</p><p>结构是不同变量类型的集合（例如如果你的角色有个物品栏，你可以设置一个拾取物品结构，结构可能包含拾取物品的名称、UI中的缩略图、用于在场景中显示的静态网格体、拾取它时会播放的音效等等）</p><h3 id="蓝图图表和事件图表"><a href="#蓝图图表和事件图表" class="headerlink" title="蓝图图表和事件图表"></a>蓝图图表和事件图表</h3><h5 id="蓝图图表"><a href="#蓝图图表" class="headerlink" title="蓝图图表"></a>蓝图图表</h5><p>Print String ：在输出日志中打印一个字符串，还可选择同时打印在屏幕上 （经常用它来调试并尝试我们的蓝图）</p><p>可以在我的蓝图中的变量中通过变量旁的“眼睛”图标决定是否公开编辑变量</p><h5 id="事件图表"><a href="#事件图表" class="headerlink" title="事件图表"></a>事件图表</h5><p>会在运行时提供信息更新蓝图脚本</p><p>选中一些节点，<strong>重叠到函数</strong>（Collapase to Function）,可以将所有节点封装到一个节点中，会被放入左侧的函数列表中</p><p>计算数值的一些节点可以框选选择<strong>重叠到宏</strong>（Collapase to Macro)</p><ul><li><u>宏没有输入，而函数有输入，宏只是为我们计算信息，然后返回这两个结果</u></li></ul><p><strong>重叠节点</strong>（Collapse Nodes）会重叠成一个图标 ，它纯粹是为了压缩体积，宏和函数都能反复调用</p><h3 id="不同种类的蓝图"><a href="#不同种类的蓝图" class="headerlink" title="不同种类的蓝图"></a>不同种类的蓝图</h3><p>关卡蓝图：位于主工具栏，一种各关卡特有的图标，可以用于编写与关卡特有的功能</p><p>关卡蓝图主要用于与关卡特有的功能，比如关卡初始化相关的脚本</p><p>关卡蓝图没有”组件“选项卡，所以也没有”视口“选项卡，只有事件图表，供我们编写关卡的绑定功能，所谓的”关卡特有的功能“就是指该图标内的任何脚本都会与该关卡绑定</p><p><img src="https://s1.ax1x.com/2020/08/03/aN8P74.png" alt=""></p><p>这是个关卡脚本内部部分，途中5.1为负责控制按钮相关的脚本，一开始有一个触发盒用于检测我们何时与之重叠，一旦按下按钮就启动齿轮BP_button，离开就停止</p><p>Actor类蓝图：可以在关卡里多次使用，或者多个关卡使用，在Actor类蓝图中编写的任何脚本都会和该Actor类相绑定，更加的模块化</p><p>动画蓝图：我们可以在使用的Character中的细节中找到Animation模块中的Anim Class（动画蓝图），进行定位后可以找到动画蓝图的位置</p><p>![](E:\Epic ue4\markdown\材料\BP\6.png)</p><p>这类资源专门用于为角色创建动画逻辑，无论你是否控制他们，动画蓝图中的事件图表用于定义各种变量，变量会在应用运行时改变，一旦更新这些变量，角色姿势也会相应更新，可以在动画图表（AnimGraph）中更新动作，动画图标允许你混合不同的动画</p><p><img src="https://s1.ax1x.com/2020/08/03/aN89nU.png" alt=""></p><p>比如设置状态机，以便在不同状态间切换</p><p><img src="https://s1.ax1x.com/2020/08/03/aN8SXT.md.png" alt=""></p><p>图中为待机、跑动、跳跃等状态</p><p>动画图表本质上允许你定义各类“最终动画姿势”，而事件图表类似于Actor类蓝图，允许你在运行时实时更新变量</p><p>控件蓝图（WIDGET BLUEPRINGT）/UMG UI：在项目中创建UI元素，它用到了UE4中的“虚幻动态图形”系统，属于一种控件蓝图</p><p><img src="https://s1.ax1x.com/2020/08/03/aN3zcV.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/08/03/aN8AhR.md.png" alt=""></p><p>它包含一个Graph</p><p><img src="https://s1.ax1x.com/2020/08/03/aN8YgP.md.png" alt=""></p><p>和其他蓝图中的事件图表非常相似，没有组件面板或组件窗口也没有视口，但有一个Designer选项卡（上上图），在这为项目设置UI的可视化布局方式，可以添加各类功能，比如动画，各类UI元素、按钮、复选框</p><p>子类蓝图（Child Blueprints）:一般蓝图类的实例，会继承父类的所有功能</p><p><img src="https://s1.ax1x.com/2020/08/03/aN8FAJ.md.png" alt="11"></p><p>使用子蓝图可以针对不同的拾取物打印不同的信息，仅需修改一点点</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p><strong>Cost</strong> associated with using Blueprintversus native C++ code</p><ul><li><strong>Avoid</strong> doing complex math or heavy operations <strong>every frame</strong></li><li>Blueprint relies on a Virtual Machine(VM)</li></ul></li><li><p>C++ is going to be faster and more powerful</p></li><li><p>Blueprint is <strong>Event Based</strong></p></li><li><p>Uses <strong>References</strong>（无效引用：设置蓝图时没有设置应用，例如按钮没有具体设置控制哪个Light，返回值为空） and possible <strong>Circular Dependency</strong> (循环依赖：两个蓝图不停的进行转化)  (蓝图通过引用来访问其他蓝图的数据和函数，稍不注意可能会获取无效的引用从而引发报错)</p></li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>Cast转换节点可以用来检测，例如检测是否为人物碰撞，这样可以避免其他Actor触发Volume</p><p><img src="https://s1.ax1x.com/2020/08/03/aN8kN9.md.png" alt="12"></p><p>这里的other actor为获取与体积发生重叠的对象，如果是就Turn on LIght，如果转换失败就print Failed</p>]]></content>
      
      
      
        <tags>
            
            <tag> UE4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4笔记（九）</title>
      <link href="/2020/07/30/%E8%99%9A%E5%B9%BB%E5%9B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
      <url>/2020/07/30/%E8%99%9A%E5%B9%BB%E5%9B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="UE4笔记（九）"><a href="#UE4笔记（九）" class="headerlink" title="UE4笔记（九）"></a>UE4笔记（九）</h1><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p><img src="https://s1.ax1x.com/2020/07/31/a1M1Wd.png" alt=""></p><p>Controller 可以由AI或玩家控制</p><p>AI框架可以帮助AI Controller根据导航网格体来决定pawn或Character的行为还有去哪里做什么</p><p>Character是一种特定类型的Pawn，它拥有Movement组件以及基本代码中内嵌的动画</p><p>Camera和Gameplay Framework与控制器和Pawn相关联</p><h3 id="概览图"><a href="#概览图" class="headerlink" title="概览图"></a>概览图</h3><p><img src="https://s1.ax1x.com/2020/07/31/a1MGQI.png" alt=""></p><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p>控制器是大脑，Pawn是身体，大脑做出决定，身体执行</p><p>控制器会在玩家（/AI）按下键盘后生成代码输入给Pawn完成指令(pawn是实例化的象征)</p><p>Character相当于加强版的Pawn，具有自带的Movement组件和一个骨骼网格体（因此可以播放动画）</p><p><img src="https://s1.ax1x.com/2020/07/31/a1MKoD.png" alt=""></p><h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><p><img src="https://s1.ax1x.com/2020/07/31/a1MJyt.png" alt=""></p><p>要向控制器发送输入事件，你可以使用Actions事件和Axis事件节点</p><p><img src="https://s1.ax1x.com/2020/07/31/a1MQFe.png" alt=""></p><p>Controller接受控制器转换为给Pawn的指令</p><h3 id="Camera"><a href="#Camera" class="headerlink" title="Camera"></a>Camera</h3><p><img src="https://s1.ax1x.com/2020/07/31/a1MlJH.png" alt=""></p><p>在Character中的Camera被附加在玩家身上，它使用弹簧臂组件（SpringArm)跟随在玩家旁边。有着内置的碰撞检测功能、内置的延迟功能     </p><p>Camera Manager可以在摄像机和过场动画摄像机中进行转换，它负责场景中所有的摄像机管理</p><p>有两种控制方法（如果我们不适用弹簧臂组件</p><p>CalcCamera 和 ViewTarget</p><p>摄像机查询的Actor可以决定摄像机的行为，反之亦然</p><h3 id="Behavior-Tree"><a href="#Behavior-Tree" class="headerlink" title="Behavior Tree"></a>Behavior Tree</h3><p><img src="https://s1.ax1x.com/2020/07/31/a1MaTS.png" alt=""></p><p>AI驱动的AI控制器</p><p><img src="https://s1.ax1x.com/2020/07/31/a1MNef.png" alt=""></p><p>这是一个简单的行为树：向我们的敌人移动，然后面对它，攻击他，然后等待两秒</p><p>它基于Blackbroad</p><p>如果说行为树负责决策，Blackbroad就是变量，行为树访问它然后了解自己该如何决策</p><p>Perception System(感知系统)也会读取行为树 例如用视觉感知来寻找玩家，有很多可以便于修改的函数，以及更多的感官：听觉、团队感知、触觉等</p><p>Environment Query System（场景查询系统）可以帮助AI躲避玩家，可以以玩家的视觉来生成大量的蓝色小球和绿色小球，蓝色为摄像机可视，并且以AI的位置在蓝色球上赋予值，来计算玩家到AI的距离帮助AI充值器对玩家做出规避。</p><p><img src="https://s1.ax1x.com/2020/07/31/a1MrSs.md.png" alt=""></p><h3 id="Nav-Mesh"><a href="#Nav-Mesh" class="headerlink" title="Nav Mesh"></a>Nav Mesh</h3><p>要在导航网格体体积内生成，必须放置体积，有不同的导航网格体代理，所以导航网格体生成的位置取决于代理而你可以设置它</p><p><img src="https://s1.ax1x.com/2020/07/31/a1MBWj.png" alt=""></p><p>如果在网格体上有一片水，然后我们希望AI不要走过水，我们可以增大这一片区域所需的开销  这叫做导航网格体权重</p><p>其他见场景构建</p><h3 id="Replication-Net"><a href="#Replication-Net" class="headerlink" title="Replication/Net"></a>Replication/Net</h3><p>需要在网络中与其他客户端共享的某个客户端变量需要将其复制</p><p><img src="https://s1.ax1x.com/2020/07/31/a1MwFg.md.png" alt=""></p><p>Character和–（往往是整个框架)  </p><p>基于拥有关系（ownership）</p><p>标上复制的属性会遭到整体修正。</p><h3 id="Gameplay-Framework"><a href="#Gameplay-Framework" class="headerlink" title="Gameplay Framework"></a>Gameplay Framework</h3><p><img src="https://s1.ax1x.com/2020/07/31/a1M0YQ.png" alt=""></p><p>通常，Pawn的控制器由GameMode认定</p><p>GameMode负责改变游戏的状态，它会关注每一个控制器，如果你需要为某个玩家赋予玩家控制器，你可以命令GameMode给这个ID添加一个玩家控制器</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>为了在导航网格体内移动，我们有了Movement组件，一个特定的MoveMent组件就是Character MoveMent，当我们有多个Character，并且要在某个空间中移动，而我们不希望他们碰撞，就有了Crowd Manager</p><p>通过Movement我们可以创建自定义移动系统</p><h3 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h3><h4 id="Controllers-and-Pawns"><a href="#Controllers-and-Pawns" class="headerlink" title="Controllers and Pawns"></a>Controllers and Pawns</h4><ul><li><p>dont fight it :Understand it!</p></li><li><p>can have different controllers and swap for different control schemas</p></li><li><p>can be used for auto testing</p></li></ul><h4 id="Character-vs-Pawn"><a href="#Character-vs-Pawn" class="headerlink" title="Character vs Pawn"></a>Character vs Pawn</h4><p>Pawn是某个拥有行为的东西，如果它同时还有碰撞、骨骼网格体和Movement组件 它可能就是Character</p><ul><li>Behavior</li><li>Collision and Skeletal Mesh</li><li>Character Movement Component</li></ul><h4 id="Movement-Component"><a href="#Movement-Component" class="headerlink" title="Movement Component"></a>Movement Component</h4><ul><li>losts of functionality</li><li>Deeply configurable</li><li>Decoupled from decisionmaking</li><li>Room for creating custom movements modes</li></ul><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><ul><li>Group actions,separate reusable keys</li><li>Easily user-configurable</li><li>Avoid BP consumption</li></ul><h4 id="Behavior-Trees"><a href="#Behavior-Trees" class="headerlink" title="Behavior Trees"></a>Behavior Trees</h4><ul><li>There can be more than one  比如进攻、躲避，可以设置两个状态在运行中切换</li><li>can change in runtime  </li><li>subtrees</li><li>fast</li><li>decouple data processing from decision</li></ul><h4 id="Workflow-with-Animations"><a href="#Workflow-with-Animations" class="headerlink" title="Workflow with Animations"></a>Workflow with Animations</h4><p>在蓝图中为Character创建一次性动画、例如翻滚</p><ul><li>React animations  </li><li>EventGraph</li><li>sockets</li><li>AnimNotifies</li></ul><h4 id="What-capsules-can-be-used-for"><a href="#What-capsules-can-be-used-for" class="headerlink" title="What capsules can be used for"></a>What capsules can be used for</h4><ul><li>Interaction and overlap</li><li>Blocking</li><li>Physics Behavior</li><li>Shadowing</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> UE4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4笔记（八）--蓝图（上）</title>
      <link href="/2020/07/25/%E8%99%9A%E5%B9%BB%E5%9B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89/"/>
      <url>/2020/07/25/%E8%99%9A%E5%B9%BB%E5%9B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="UE4笔记（八"><a href="#UE4笔记（八" class="headerlink" title="UE4笔记（八)"></a>UE4笔记（八)</h1><h1 id="蓝图入门-上"><a href="#蓝图入门-上" class="headerlink" title="蓝图入门(上)"></a>蓝图入门(上)</h1><p>BP’s focus is on making it <strong>accessible</strong>,versatile and powerful to anyone in the team.</p><p>It is meant to <strong>empower the entire team</strong> to make a maximum impact.</p><p>While <strong>freeing up the programmers</strong> <strong>and engineers</strong> from simple tasks.(例如更改武器上的粒子效果)</p><p>Easy to understand and build upon. <strong>Fast to iterate on</strong>. Invites experimentation.</p><p>But also a <strong>robust scripting system</strong> that holds up even at large scale.</p><p><img src="https://s1.ax1x.com/2020/07/26/aCaHc4.png" alt=""></p><p>首先C++是一切的基础，所以BP和C++有密切的关联。Framework Classes是框架类，他会影响到C++，通过扩展项，影响到蓝图，Replication(复制)不仅存在C++也存在BP中。</p><p>BP会通过Inheritance(继承)来继承C++代码中的函数，让这两者可以无缝对接。</p><p>Data Features(数据特性)用来存储数据，并让C++或BP从特定资产中读取数据。</p><p>BP本身包含Components(组件)，Timeline(时间轴)，Core BP Tools(核心BP工具)</p><p>Additonal Features(额外功能) &amp; Editor Scripting(编辑脚本) 总的来说，蓝图不只是一个脚本系统，它不光用来编写Gameplay脚本或者各种东西，It is very extensively used in the whole engine.</p><p>7+ Tools and sub-Editors 会以各种方式用到蓝图</p><p>BP to BP Communication Features (蓝图间的通信)   Complication &amp; Execution(编译和执行)  Debuging and Performance Features (调试性能表现)</p><h2 id="蓝图的图解概览"><a href="#蓝图的图解概览" class="headerlink" title="蓝图的图解概览"></a>蓝图的图解概览</h2><p>总浏览</p><p><img src="https://s1.ax1x.com/2020/07/26/aCsJa9.png" alt=""></p><h2 id="Core-C-BP-Supporting-Features"><a href="#Core-C-BP-Supporting-Features" class="headerlink" title="Core C++ BP Supporting Features"></a>Core C++ BP Supporting Features</h2><p><img src="https://s1.ax1x.com/2020/07/26/aCy9o9.md.png" alt=""></p><p>Interitance(继承): Classes derive and inherit from their parent classes(类从它们的父类派生和继承).基于继承系统，<strong>that is a core part of the functionality</strong></p><p><img src="https://s1.ax1x.com/2020/07/26/aCcOzt.png" alt=""></p><p>象征继承的图标，上面是Actor、Pawn、Wheeled Vehicle or OurVehicles 这就是我们制作的类，这是框架的一部分，事实上这里有一个Pawn和多个带轮子的载具，然后你可以用一个自定的类或者说Vehicles or cars 来扩展它，然后在它下面又有一个蓝图类，基于C++创建，然后又有一个蓝图类基于上一个构建，叫做Sedan</p><p>然后是Events/Functions/Var(事件函数 或者变量),作为蓝图的核心结构，能在蓝图中被创建，大部分来自于C++</p><p><img src="https://s1.ax1x.com/2020/07/26/aCc3qS.md.png" alt=""></p><p>这是在C++里定义新的蓝图函数或变量时所需的所有代码。这非常非常便于拓展，设计时就旨在无缝集成C++、BP，它不是两个系统而是一个整体，相同的东西。只要一个说明符就能创建一个函数或新变量的新节点在蓝图中可见。</p><p>Function Libraries(函数库) 它可以在蓝图中完成，也可以在C++里编写这些函数，然后向项目中任意的蓝图公开它们。</p><p>Framework(框架) 我的理解是，你在使用UE4引擎的时候，会选择游戏的mode，例如你选择了第一人称游戏项目，UE4引擎就会给你一个生成第一人称游戏所需的最少信息，基本上，你可以以此在几乎没有函数的情况下完成一款第一人称游戏。</p><p><img src="https://s1.ax1x.com/2020/07/26/aCWNwT.png" alt=""></p><p>关于第一人称的底层代码和函数都已经包含在了项目中，从movement component到 the game modes 到Replication等等，就像上方框选的，它只是总结了一些可能是最重要的一些类。这是虚幻引擎非常关键的一部分，这些函数默认存在，是你的基础。</p><p>常见的父类</p><ul><li>Actor  一个可以在世界中摆放，或者生成的Actor。</li><li>Pawn  Pawn是一个可以从控制器获得输入信息处理的Actor.</li><li>Character  角色是一个包含了行走，跑步，跳跃以及更多动作的Pawn.</li><li>PlayerController   角色控制器</li><li>Game Mode  一个Game Mode 定义了游戏是如何被执行的，游戏规则，如何的分以及其他方面的内容。</li></ul><h3 id="Optional-Data-Features"><a href="#Optional-Data-Features" class="headerlink" title="Optional Data Features"></a>Optional Data Features</h3><p><img src="https://s1.ax1x.com/2020/07/26/aCf4ET.md.png" alt=""></p><p>Data Tables(数据表)、Data Assets(资产)、Curves(曲线) </p><p>蓝图也可以使用它们在编程时作为引用</p><h3 id="Core-Features-of-BP"><a href="#Core-Features-of-BP" class="headerlink" title="Core Features of BP"></a>Core Features of BP</h3><p><img src="https://s1.ax1x.com/2020/07/26/aC55Uf.md.png" alt=""></p><p>待续………….</p>]]></content>
      
      
      
        <tags>
            
            <tag> UE4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4笔记（七）</title>
      <link href="/2020/07/22/%E8%99%9A%E5%B9%BB%E5%9B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89/"/>
      <url>/2020/07/22/%E8%99%9A%E5%B9%BB%E5%9B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="UE4笔记（七"><a href="#UE4笔记（七" class="headerlink" title="UE4笔记（七)"></a>UE4笔记（七)</h1><h2 id="体积（Volumes）"><a href="#体积（Volumes）" class="headerlink" title="体积（Volumes）"></a>体积（Volumes）</h2><p>体积是一种特殊的Actor，它有很多的用途：限制玩家的移动范围，决定音响的混响效果等，UE4中很多交互机制都是由体积决定的。</p><p><img src="https://s1.ax1x.com/2020/07/22/UTckrD.png" alt=""></p><h3 id="Lightmass-Volume"><a href="#Lightmass-Volume" class="headerlink" title="Lightmass Volume"></a>Lightmass Volume</h3><p>它有两大作用：限定Lightmass的模拟范围、它允许动态对象（如玩家）了解静态光源环境。</p><p>1.限定Lightmass的模拟范围。它决定了Lightmass计算过程中计算最密集和最简单的区域，如果没有Lightmass，你会把计算时间浪费在没有任何光线或无关紧要的场景区域，添加Lightmass体积能确保只有玩家能够看到或与之互动的区域才会被纳入光照计算，从而有助于减少场景的实际光照计算时间（减少需要计算的对象数量）。</p><p>2.允许动态对象（如玩家）了解静态光源环境。当现实世界中有东西移动时，我们能看到光线在它的表面移动，因为光线是完全动态的，我们可以和他互动，但是电子游戏无法完全模拟动态光照的实时互动效果，我们需要使用光照贴图和阴影贴图，光照无法移动也无法更新。为解决该问题，整个场景中会添加“Lightmass重要取样”的小型光照探针</p><p><img src="https://s1.ax1x.com/2020/07/22/UTcZad.png" alt=""></p><p>上图所示的这些均匀分布色彩各异的小方块就是采样点，它记录了所在位置的光源烘焙信息，当动态对象靠近的时候就会计算这些采样点的数据来形成动态光照的效果。</p><h3 id="Lightmass角色间接细节体积（Lightmass-Character-Indirect-Detail-Volumes）"><a href="#Lightmass角色间接细节体积（Lightmass-Character-Indirect-Detail-Volumes）" class="headerlink" title="Lightmass角色间接细节体积（Lightmass Character Indirect Detail Volumes）"></a>Lightmass角色间接细节体积（Lightmass Character Indirect Detail Volumes）</h3><p>间接细节体积的作用是增加该体积内的取样数量（增多采样点），它可以放置在电梯这样狭小、采样不足的环境之中，使得角色可以正确的获得光照的信息。</p><p>在世界场景设置中搜索Lightmass设置-静态光照等级范围 也能改变光照体积取样的密度。</p><h3 id="剔除距离体积（Cull-Distance-Volume）"><a href="#剔除距离体积（Cull-Distance-Volume）" class="headerlink" title="剔除距离体积（Cull Distance Volume）"></a>剔除距离体积（Cull Distance Volume）</h3><p>剔除距离体积是一种优化工具，允许你确保对象在超出特定大小和到摄像机的特定距离的时候不再被渲染。</p><p>选中体积之后，使用细节（Details）面板访问剔除距离（Cull Distance）</p><p><img src="https://s1.ax1x.com/2020/07/22/UTcAqe.png" alt=""></p><p>这些参数表示，该体积中大小最接近100单位的对象会在它们距摄像机350单位或更远时被从视野中剔除。</p><p><img src="https://s1.ax1x.com/2020/07/22/UTcVVH.png" alt=""></p><p>该体积中大小最接近 1000 单位的对象将永不会被剔除。这可以确保尺寸极大的对象被视为无穷大，这意味着它们距摄像机的距离永不可能远到应将它们剔除的程度。</p><p>如果希望某个对象持续被渲染，那可以在该网格体的Detail中搜索cull：</p><p>将”允许剔除距离体积”禁用</p><h5 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h5><p>关卡或蓝图中的所选Actor包含可通过其 细节（Details） 面板访问的距离设置。它们支持设置按实例距离，或者是否使用剔除距离体积来剔除Actor。</p><p><img src="https://docs.unrealengine.com/Images/Engine/Rendering/VisibilityCulling/VisibilityCullingReference/DetailsPanel-1.webp" alt=""></p><table><thead><tr><th align="center">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center"><strong>最小绘制距离（Min Draw Distance）</strong></td><td align="left">设置将在场景中渲染对象的最小绘制距离。该距离以场景空间单位（厘米）测量，具体是指从对象边界球体中心到摄像机位置。</td></tr><tr><td align="center"><strong>所需最大绘制距离（Desired Max Draw Distance）</strong></td><td align="left">设置关卡设计器的最大绘制距离。”真实”最大距离是 <strong>最小绘制距离（Min Draw Distance）</strong>（忽略0）。</td></tr><tr><td align="center"><strong>当前最大绘制距离（Current Max Draw Distance）</strong></td><td align="left">将开始剔除对象的只读距离。该值表示的是 <strong>最小绘制距离（Min Draw Distance）</strong> 或者剔除距离体积为参照而设置的 <strong>剔除距离（Cull Distances）</strong>。显示值0时，表示不应剔除该对象。</td></tr><tr><td align="center"><strong>从不距离剔除（Never Distance Cull）</strong></td><td align="left">启用时，该对象不会按距离剔除。如果它是层级细节层次（LOD）网格体的子代，也会被忽略。</td></tr><tr><td align="center"><strong>允许剔除距离体积（Allow Cull Distance Volume）</strong></td><td align="left">是否接受剔除距离体积的剔除距离值修改缓存的剔除距离。</td></tr><tr><td align="center"><strong>视为遮挡背景（Treat as Background for Occlusion）</strong></td><td align="left">允许将该对象视为部分背景以达到遮挡目的。这可以用作一种优化方法，降低天空盒、大型地面（远景的一部分）等内容的渲染开销。</td></tr><tr><td align="center"><strong>用作遮挡物（Use as Occluder）</strong></td><td align="left">是否渲染仅深度通道中的Primitive。这通常对于所有对象都是成立的，让渲染者决定是否渲染仅深度通道中的对象。</td></tr></tbody></table><h1 id="照明阴影和后期处理"><a href="#照明阴影和后期处理" class="headerlink" title="照明阴影和后期处理"></a>照明阴影和后期处理</h1><h3 id="光照（Lighting）"><a href="#光照（Lighting）" class="headerlink" title="光照（Lighting）"></a>光照（Lighting）</h3><p>光照有三种可移动类型：静态（static）、固定（Stationary）、可移动（Movable）。其中静态（static）的开销最小。</p><p>静态意味着：不会做任何运动，没有互动，光源信息完全靠烘焙，它不能以任何形式改变其形状或形式（状态）。</p><p>固定（固定光源）：可以与场景互动，所以固定光源投射的阴影能够和动态对象融合到一起，但是它拥有一定的开销，因为你可以在运行时改变它的颜色和亮度，但是你不能移动它。</p><p>动态：动态的开销是最大的，它可以随意的移动，其光影包括所有的效果完全是动态的</p><p><img src="https://s1.ax1x.com/2020/07/22/UT2gv6.md.png" alt=""></p><h4 id="构建光照"><a href="#构建光照" class="headerlink" title="构建光照"></a>构建光照</h4><p>在【构建→光照质量】中，可以选择4个级别的光照：制作（Production）、高级（High）、中级（Medium）、预览（Preview）。等级从高到低排序。</p><p>预览：预览将会以最简陋的方式展现光照的信息，可能会出现奇怪的斑点、阴影，但是可以通过预览大体知道能否达到想要的效果，比如光照的范围等基础信息。其速度也是最快的。</p><p>从中级到制作其实就是逐级提升的过程，一般在制作中使用中级和预览就可以，它能够保证基本的信息正确且拥有较快的渲染速度，我们可以通过调整光照贴图的分辨率来消除斑点，提升光照的效果。当项目发布时则需要使用“制作”，它可以提供最佳的渲染效果，但是也最耗时间。</p><h3 id="阴影（Shadowing）"><a href="#阴影（Shadowing）" class="headerlink" title="阴影（Shadowing）"></a>阴影（Shadowing）</h3><p>阴影分为两大类：静态阴影和动态阴影。</p><p>1.静态阴影源于静态光源，它开销极低，但是和场景没有任何互动。</p><p>2.动态阴影源于固定光源和移动光源，它开销很大，但是具备完整的场景互动效果。</p><p>UE4同时还提供了一些特殊的阴影：级联阴影（Cascaded Shadows）、距离场阴影（Distance Field Shadows）、接触阴影（Contact Shadows）。</p><h5 id="静态阴影（静态光源产生的阴影）"><a href="#静态阴影（静态光源产生的阴影）" class="headerlink" title="静态阴影（静态光源产生的阴影）"></a>静态阴影（静态光源产生的阴影）</h5><p><img src="https://s1.ax1x.com/2020/07/22/UT2CnO.png" alt=""></p><p>可以看到此时的阴影具有不错的效果，随着距离的变化阴影会逐渐的模糊化，柔化的阴影非常逼真，但是静态阴影是直接烘焙在贴图上的，即使我们将物体移开，地上的阴影也不会产生变化</p><h5 id="动态阴影（固定光源产生的阴影）"><a href="#动态阴影（固定光源产生的阴影）" class="headerlink" title="动态阴影（固定光源产生的阴影）"></a>动态阴影（固定光源产生的阴影）</h5><p><img src="https://s1.ax1x.com/2020/07/22/UT2wbF.png" alt=""></p><p>虽然这种阴影可以随着物体的移动而移动，但是可以看到阴影的效果不如静态阴影，菱角分明——衰减效果不够理想。</p><p><img src="https://s1.ax1x.com/2020/07/22/UTgbBF.png" alt=""></p><p>不但阴影会随着物体的移动而移动，就连物体（例如上面这个人物Actor）的变化都会影响到阴影。奔跑时的人的影子是实时变化的。</p><p><img src="https://s1.ax1x.com/2020/07/22/UTgq74.png" alt=""></p><p>当两块动态阴影重叠的时候会产生融合效果，这也是静态阴影所做不到的。这也是为什么固定光源位于静态光源与动态光源之间的原因，它融合了两者的优点。然而刚刚的静态方块在被移动后地上同样有一块阴影，这是因为对静态的物体进行了阴影烘焙。</p><h5 id="动态阴影（动态光源产生的阴影）"><a href="#动态阴影（动态光源产生的阴影）" class="headerlink" title="动态阴影（动态光源产生的阴影）"></a>动态阴影（动态光源产生的阴影）</h5><p><img src="https://s1.ax1x.com/2020/07/22/UT2JCn.png" alt=""></p><p>可以看到阴影完全没有柔化效果，但是阴影的融合却达到了极致。在静态的方块被移动后，地上并没有留下阴影，这是因为现在使用的都是动态光源，烘焙完全是实时动态的。</p><h5 id="级联阴影"><a href="#级联阴影" class="headerlink" title="级联阴影"></a>级联阴影</h5><p><img src="https://s1.ax1x.com/2020/07/22/UT2Sc6.png" alt=""></p><p>它融合了静态阴影和动态阴影的优点，当摄像机靠近物体时，阴影将会被切换到动态阴影，即阴影会随着物体的变化而变化。而当摄像机原理时，则会切换会静态阴影，无论物体如何运动阴影都不会产生变化。</p><p>阴影切换距离的设置需要找到对应的光源，并在光源的细节中搜索“cas”找到csm（级联阴影的缩写）选项，即可调整阴影切换距离和数量。</p><p>需要注意的是这种阴影只适用于定向光源。</p><h5 id="距离场阴影"><a href="#距离场阴影" class="headerlink" title="距离场阴影"></a>距离场阴影</h5><p>距离场阴影使用了网格体距离场实现光源和阴影的互动效果，提供了出色的阴影衰减效果。</p><p><img src="https://s1.ax1x.com/2020/07/22/UT2QHg.png" alt=""></p><p>这个特性也非常的昂贵，它可以在点光源中使用，但是需要<strong>开启距离场</strong>才能使用：</p><p><img src="https://s1.ax1x.com/2020/07/22/UT2mgP.png" alt=""></p><h5 id="接触阴影"><a href="#接触阴影" class="headerlink" title="接触阴影"></a>接触阴影</h5><p>接触阴影比较特殊因为它是在屏幕空间中完成的阴影，但是其代价相当昂贵。</p><p><img src="https://s1.ax1x.com/2020/07/22/UTgOAJ.png" alt=""></p><p>当我们渲染面部等细节十分复杂的模型时阴影效果会变得很糟，因为没有足够的阴影缓存来存储这些阴影数据。一般来说十分精细的阴影效果多用于游戏过场动画和电影中，如果需要开启这个选项需要在光源→细节→搜索contact，从0到1效果逐渐变得细节化。但是当接近1的时候则需要强大的电脑性能，否则可能会崩溃，导致渲染的效果不如勾选之前<br><img src="https://s1.ax1x.com/2020/07/22/UTgx91.png" alt=""></p><h3 id="后期处理体积"><a href="#后期处理体积" class="headerlink" title="后期处理体积"></a>后期处理体积</h3><p>后期处理由体积负责实现，但是也和渲染相关。它属于会快速消耗性能的内容：</p><p><img src="https://s1.ax1x.com/2020/07/22/UT2WDO.png" alt=""></p><p>打开后期处理体积设置</p><p>Infinite Extent（无限范围），勾选了这个选项意味着整个场景中的所有对象即使没有被这个体积覆盖也会受到它的影响。如果没有勾选这个选项的话，那它就和传统的体积一样只会在当前的作用域内起作用，当玩家进入到这个体积之后就会出现后期处理效果。（即玩家进入到后期处理体积之后，画面会受到后期处理体积设置的影响）</p><p>可以通过其他的选项控制整个场景的色温、着色、饱和度等等功能。通过蓝图可以实现爆炸以后的色温从高到正常等电影效果画面。</p><p>用于控制场景的抗锯齿设置位于  编辑项目设置—渲染—默认设置—抗锯齿方法</p><h2 id="反射（Reflections）"><a href="#反射（Reflections）" class="headerlink" title="反射（Reflections）"></a>反射（Reflections）</h2><p>UE4中主要有3种类型的反射：球体反射、盒体反射、平面反射。前两者开销最低。三种反射都是通过在场景中放置Actor来实现效果。</p><h3 id="球体反射"><a href="#球体反射" class="headerlink" title="球体反射"></a>球体反射</h3><p>当前球形最为实用。其永远不会匹配被反射几何体的外形， 但不含间断或角落，因此错误一致。</p><p><img src="https://docs.unrealengine.com/Images/Engine/Rendering/LightingAndShadows/ReflectionEnvironment/SphereShape.webp" alt=""></p><p>球形拥有橙色的影响半径，控制会受立方体贴图影响的像素、 以及关卡将被重新投射到的球体。</p><p>较小的采集将覆盖较大的采集，因此在关卡周围放置较小的采集能够进行提升。</p><h3 id="盒体反射"><a href="#盒体反射" class="headerlink" title="盒体反射"></a>盒体反射</h3><p>盒形的实用性十分有限，通常只用于走廊和矩形房间。 其原因是只有盒体中的像素可看到反射，同时盒体中的所有几何体将投射到盒体上， 在很多情况下会出现重大瑕疵。</p><p><img src="https://docs.unrealengine.com/Images/Engine/Rendering/LightingAndShadows/ReflectionEnvironment/BoxShape.webp" alt=""></p><p>选中盒体后，投射形状将拥有一个橙色预览。 其只采集此盒体外盒体过渡距离之内的关卡。 此采集的影响也会在盒体中随过渡距离淡入。</p><h3 id="平面反射"><a href="#平面反射" class="headerlink" title="平面反射"></a>平面反射</h3><p>UE4 支持实时平面反射，它比屏幕空间反射（SSR）更加精确，但渲染开销较高。渲染开销较高的原因来自平面反射的工作原理。因为平面反射实际上将从反射方向再次对关卡进行渲染。</p><p><img src="https://docs.unrealengine.com/Images/Engine/Rendering/LightingAndShadows/PlanarReflections/planarReflections_Banner.webp" alt=""></p><h4 id="启动平面反射"><a href="#启动平面反射" class="headerlink" title="启动平面反射"></a>启动平面反射</h4><p>执行下列操作即可在项目中启用并使用平面反射：</p><p>1.在主工具栏中前往编辑（Edit）&gt; 项目设置（Project Settings），然后前往项目设置菜单下的 渲染（Rendering）&gt; 优化（Optimizations） 部分。</p><p><img src="https://docs.unrealengine.com/Images/Engine/Rendering/LightingAndShadows/PlanarReflections/PR_Project_Settings_00.webp" alt=""></p><p>2.点击 支持平面反射的全局裁剪平面（Support global clip plane for Planar Reflections）旁边的勾选框，在弹出提示后重启UE4编辑器。</p><p><img src="https://docs.unrealengine.com/Images/Engine/Rendering/LightingAndShadows/PlanarReflections/PR_Enable_PR_00.webp" alt=""></p><p><u>启用平面反射后如未重启UE4编辑器，可能导致平面反射无法使用。</u></p><p>3.重启UE4编辑器后，前往模式（Modes）面板，从 视觉效果（Visual Effects）部分选择一个 平面反射Actor 并将其拖入关卡。</p><p><img src="https://docs.unrealengine.com/Images/Engine/Rendering/LightingAndShadows/PlanarReflections/Adding_Planar_Reflection_Actor.webp" alt=""></p><p>4.将平面反射Actor放进关卡后，即可使用 G 键隐藏或取消隐藏 Actor。可使用 移动、旋转和缩放工具更佳地放置平面反射Actor并设置大小，满足关卡需求。</p><p>平面反射Actor有多个属性，当调整这些属性时，会大大影响反射的显示效果。</p><p><a href="https://docs.unrealengine.com/zh-CN/Engine/Rendering/LightingAndShadows/PlanarReflections/index.html" target="_blank" rel="noopener">平面反射官方文档</a></p><h3 id="屏幕空间反射—-SSR（Screen-Space-Reflections）"><a href="#屏幕空间反射—-SSR（Screen-Space-Reflections）" class="headerlink" title="屏幕空间反射—-SSR（Screen Space Reflections）"></a>屏幕空间反射—-SSR（Screen Space Reflections）</h3><p>在后期处理体积中。</p><p>对于球体反射和盒体反射，任何动态的物体都不会纳入到考虑范围。如果你想要捕捉动态的网格体的反射，就需要SSR。</p><p><img src="https://s1.ax1x.com/2020/07/22/UThBsx.png" alt=""></p><p>屏幕空间反射效果默认启用，可改变材质表面物体的外观。下方列出了用于调整此效果的几个选项。</p><p><strong>Intensity</strong>：按百分比启用/淡出/禁用屏幕空间反射功能（为保持一致性，不使用 0 到 1 之间的数字）。</p><p><strong>Quality</strong>：0 为最低精度，100 为最高精度（50 为默认精度，性能较好）。</p><p><strong>Max Roughness</strong>：用于确定屏幕空间反射淡出的平整度（0.8 效果较好，数值越小，运算越快）。</p><h3 id="获得更高质量的反射效果"><a href="#获得更高质量的反射效果" class="headerlink" title="获得更高质量的反射效果"></a>获得更高质量的反射效果</h3><p>因为UE4是一款实时引擎，因此我们要尽可能降低整体的反射捕获频率，我们可以通过提高分辨率来获得更高质量的反射效果：</p><p>项目设置→渲染→反射捕获分辨率</p><p><img src="https://img-blog.csdnimg.cn/20200521230925662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>还有一种增加立方体贴图分辨率的方法是添加一个天空光源，其中有一个立方贴图分辨率的属性：</p><p><img src="https://img-blog.csdnimg.cn/20200521231257941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>第三种提高反射效果的方式是“高精度静态网格体法线和切线编码”</p><p><img src="https://img-blog.csdnimg.cn/20200521231608751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>左图即为开启了高精度静态网格体发现的图，它能使得线条更加的柔和流畅，如何开启呢？它位于网格体细节里面的LOD分级中：</p><p><img src="https://img-blog.csdnimg.cn/20200521231728667.png" alt=""></p><p>然后到项目设置中</p><p><img src="https://img-blog.csdnimg.cn/20200521231845564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>最后一种提高反射质量的方法是确保网格体的曲面细分程度足够高，网格体使用的顶点越多，像素之间的插值就越好</p>]]></content>
      
      
      
        <tags>
            
            <tag> UE4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4笔记（六）</title>
      <link href="/2020/07/21/%E8%99%9A%E5%B9%BB%E5%9B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/"/>
      <url>/2020/07/21/%E8%99%9A%E5%B9%BB%E5%9B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="UE4笔记（六"><a href="#UE4笔记（六" class="headerlink" title="UE4笔记（六)"></a>UE4笔记（六)</h1><h2 id="性能与优化"><a href="#性能与优化" class="headerlink" title="性能与优化"></a>性能与优化</h2><h3 id="纹理流送（Texture-Streaming）"><a href="#纹理流送（Texture-Streaming）" class="headerlink" title="纹理流送（Texture Streaming）"></a>纹理流送（Texture Streaming）</h3><p>纹理流送能在摄影机接近场景对象或者远离场景对象时流送不同的细节层次。</p><p>纹理流送设有一个缓存池：一片专门用于缓存多级渐进纹理的内存区域。随着纹理不断远离摄像机，他们会变得越来越小，在纹理流送池中占用的内存也越来越少直到不再占用任何内存，接近摄像头就会变得越来越大，所占内存也会越大。</p><p>如果遇见纹理流送池的可用空间不足，就说明内存池预先分配的空间太少。如果要增加内存池大小：</p><p>1.打开UE4控制台，点击“~”键打开控制台。</p><p>2.输入“r.Streaming.PoolSize=5000”   (r.Streaming.PoolSize=SizeInMB(取决于你的项目情况))</p><p>还能打开文件夹中的DefaultEngine.ini文件，在/Script/Engine.RendererSettings下输入“r.Streaming.PoolSize=5000”,这是一种方法在UE4每次启动后自动获得正确的流送池大小。</p><h3 id="强制纹理不流送-Forcing-Textures-to-never-stream"><a href="#强制纹理不流送-Forcing-Textures-to-never-stream" class="headerlink" title="强制纹理不流送(Forcing Textures to never stream)"></a>强制纹理不流送(Forcing Textures to never stream)</h3><p>它能确保始终显示最高分辨率的纹理，可以将靠近用户体验的纹理使用“永不流送”，比如UI元素，文本元素。</p><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>使你的纹理永远维持在最高分辨率</p><p>1.打开一张纹理图</p><p><img src="https://s1.ax1x.com/2020/07/21/U534l8.md.png" alt=""></p><p>2.在层次细节中勾选从不流送</p><p><img src="https://s1.ax1x.com/2020/07/21/U53WfP.png" alt=""></p><p>3.在压缩栏中 将压缩设置改为“用户界面”</p><p><img src="https://s1.ax1x.com/2020/07/21/U53RYt.png" alt=""></p><p>这会让它的渲染开销变得非常大，不仅是在内存中，而且屏幕绘制开销也会变大，因为他没有压缩，它永远都不会使用其他渐进纹理，即使它在屏幕中只占200或100像素和占2000像素的开销是一样的。</p><p><u>让你获得最高质量的效果，影响性能</u></p><h2 id="LOD与合并静态网格体"><a href="#LOD与合并静态网格体" class="headerlink" title="LOD与合并静态网格体"></a>LOD与合并静态网格体</h2><h3 id="LOD的自动创建工具（Automatic-LOD-Creation-Tools）"><a href="#LOD的自动创建工具（Automatic-LOD-Creation-Tools）" class="headerlink" title="LOD的自动创建工具（Automatic LOD Creation Tools）"></a>LOD的自动创建工具（Automatic LOD Creation Tools）</h3><p>1.选择一个静态网格体，打开静态网格编辑器</p><p><img src="https://s1.ax1x.com/2020/07/21/U53toR.md.png" alt=""></p><p>2.找到LOD setting分组（LOD设置），有一个属性“LOD Group”</p><p><img src="https://s1.ax1x.com/2020/07/21/U53ZZj.png" alt=""></p><p>LOD中预存了许多类型的分组，比如Foliage、HightDetail等，当你选择其中一个的时候，UE4会读取BaseEngine.ini中的配置数据，并按照预设好的配置为该静态网格体生成指定规格的LOD数据；</p><p><img src="https://img-blog.csdnimg.cn/20200518220609695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p><img src="https://s1.ax1x.com/2020/07/21/U53Asg.png" alt=""></p><p>例如我这里选择了HighDetail的分组，它的LOD数量变为了6。LOD导入功能让你导入LOD级别</p><h3 id="手动修改LOD参数（Manual-LOD-Setup）"><a href="#手动修改LOD参数（Manual-LOD-Setup）" class="headerlink" title="手动修改LOD参数（Manual LOD Setup）"></a>手动修改LOD参数（Manual LOD Setup）</h3><p>上面我们已经生成了六个LOD级别，通过LOD选取器选择我们想要调节的LOD级别</p><p><img src="https://s1.ax1x.com/2020/07/21/U531QU.png" alt=""></p><p>我这里选择的为LOD1，可以在下面的LOD1的参数配置修改中修改LOD1参数，比如融合阈值，它表示着当两个顶点（取决于你选择的内容）小于阈值时将会自动合并，从而减少渲染分支。</p><p><img src="https://s1.ax1x.com/2020/07/21/U533yF.png" alt=""></p><p>上图表示当屏幕大小为多少倍时将会启用当前的LOD。此处是默认值，因为我们用的是系统自带的，可以手动修改定制。</p><p>回到UE4中，点击一个指定的静态网格体，我们可以在细节面板中找到LOD，并将“Forced Lod Model”设置为指定值，这样就可以强制渲染该网格体为指定的LOD等级而不受到屏幕距离的影响。</p><p><img src="https://s1.ax1x.com/2020/07/21/U53JeJ.png" alt=""></p><p>如果将重载最小LOD打开，将最小LOD调为2，意味着一开始使用LOD2，然后持续显示LOD直到看到最小的LOD，这样能根据关卡需求直接调整LOD而不用打开静态网格</p><h3 id="Actor融合工具（Merge-Actor-Tool）"><a href="#Actor融合工具（Merge-Actor-Tool）" class="headerlink" title="Actor融合工具（Merge Actor Tool）"></a>Actor融合工具（Merge Actor Tool）</h3><p><img src="https://s1.ax1x.com/2020/07/21/U53Yw9.md.png" alt=""></p><p>左边的图片有58个静态网格体，14种不同的材质，51K的三角形，使用过Actor融合工具后转换为一个静态网格体，一个材质，三角形不变。这有效的减少了整体的渲染消耗，无论是内存占用还是屏幕的渲染开销。（减少了13种材质，外加他们的漫反射、粗糙程度、法线贴图）</p><p>融合Actor时，选中所有需要融合的网格体，然后在菜单栏中找到窗口→开发者工具→合并Actor</p><p><img src="https://s1.ax1x.com/2020/07/21/U53KJ0.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/07/21/U53QzT.png" alt=""></p><p>简单说一下设置内容：</p><p>1.零处的枢轴点（Pivot Point at Zero）:  它会保证合并后的枢纽点位于0点，从而方便操作</p><p>2.合并物理数据  (Merge Physics Data) ：合并物理数据</p><p>3.将顶点数据烘焙为网格体（Bake Vertex Data to Mesh）：它会合并顶点动画等Mesh数据，保证顶点动画等信息在合并后能正常使用</p><p>下面关于LOD选项类型  <u>建议使用Use specific LOD level，这非常重要！</u></p><p><img src="https://img-blog.csdnimg.cn/20200518224713113.png" alt=""></p><p>Use all LOD levels:当前的使用所有LOD层级不允许我们选择或调整新材质的创建方式，它的作用是获取所有当前信息，创建一个完整的大网格体然后使用所有的LOD  </p><p>Use specific LOD level：这样所有的网格体就会使用同一个LOD，尽量写0因为不确定是否所有的网格体都具有相同的LOD设置，只有LOD0是所有网格体都共同拥有的。</p><p><img src="https://s1.ax1x.com/2020/07/21/U53eds.png" alt=""></p><p>在高级选项下有”生成光照贴图UV“和”目标光照贴图分辨率“</p><p>用于确保光照贴图是根据光照计算并添加到UV通道中</p><p><img src="https://s1.ax1x.com/2020/07/21/U538L4.png" alt=""></p><p>进行材质设置之前一定要在前面LOD设置中选择Use specific LOD level</p><p>选择合并材质，按照所选的网格体进行材质的数据选择。</p><p> 下面的地形剔除，选用地形剔除意味着任何与地形相交的网格体的不可见部分都会被剔除</p><p>最后是”替换源Actor“：用新生成的网格体替换被选中和融合的Actor</p><p>在融合时为了避免融合出错，我们可以选中要融合的网格体之后按Ctrl+C，此时这些网格体将会被以代码的形式储存下来：</p><p><img src="https://img-blog.csdnimg.cn/20200518225228214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>一旦出错只需要复制这些代码然后粘贴在世界大纲视图中即可</p><h3 id="分层细节层级工具（Hierarchical-Level-of-Detail-Tool）HLOD"><a href="#分层细节层级工具（Hierarchical-Level-of-Detail-Tool）HLOD" class="headerlink" title="分层细节层级工具（Hierarchical Level of Detail Tool）HLOD"></a>分层细节层级工具（Hierarchical Level of Detail Tool）HLOD</h3><p>Actor融合工具虽然效果好，但是有一点不方便，我们需要一些额外的步骤用于在融合错误对象时进行补救，HLOD的优点在于你可以随时撤销和删除生成的群集或融合后的网格体，引擎在后台为你记录了所有的操作，你可以随时重新推倒再来一遍。</p><p>窗口→世界设置→LOD System 确保在LOD系统分段中打开启动层级LOD系统</p><p><img src="https://s1.ax1x.com/2020/07/21/U53kQS.png" alt=""></p><p>点击窗口打开层级LOD大纲视图</p><p><img src="https://img-blog.csdnimg.cn/2020051822594152.png" alt=""></p><p>点击生成群集</p><p><img src="https://s1.ax1x.com/2020/07/21/U53uiq.png" alt=""></p><p>这一步大体工作如下：在世界大体将这些网格体分组，然后将组内物体合并。网格体细节不变，但是将会赋予这几个分组（比如两三个）两三个纹理和材质，这样当摄像机远离的时候将极大的降低渲染相同对象的消耗<br>生成结束之后我们点击生成代理网格体<u>（这一步相当于融合Actor）</u></p><p>一些层级LOD设置</p><p><img src="https://s1.ax1x.com/2020/07/21/U53MWV.png" alt=""></p><p>群集生成设置（Cluster generation settings）：它的作用是HLOD系统会查看关卡，并且放置许多体积，然后为体积中的所有Actor都生成一个新的网格体，例如在一个组有30个网格体，HLOD将他们转化为两到三个网格体，细节程度仍然不变，但它会获取这两到三个网格体，赋予它们两到三种材质和两到三张纹理</p>]]></content>
      
      
      
        <tags>
            
            <tag> UE4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4笔记（五）</title>
      <link href="/2020/07/19/%E8%99%9A%E5%B9%BB%E5%9B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2020/07/19/%E8%99%9A%E5%B9%BB%E5%9B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="UE4笔记（五"><a href="#UE4笔记（五" class="headerlink" title="UE4笔记（五)"></a>UE4笔记（五)</h1><h2 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h2><h3 id="PBR"><a href="#PBR" class="headerlink" title="PBR"></a>PBR</h3><p>PBR的全称为 Physical Based Rendering(基于物理的渲染)，基于物理的渲染意味着我们根据事实模拟光线，而不是根据主观想法，光线的最终效果会更加准确且自然。</p><p>PBR是两个做卡通渲染风格的工作室合作的产物，因此PBR在卡通渲染方面也很不错，PBR有助于我们变准话美工管线，因为材质无论遇到怎样的光照都能做出相同反应（这意味着我们不需要根据物体的光照环境创建多个材质或者纹理）</p><p><u>This is the same type of redering pipeline that you will find in programs like Vary.</u></p><h3 id="材质域-Material-Domain"><a href="#材质域-Material-Domain" class="headerlink" title="材质域(Material Domain)"></a>材质域(Material Domain)</h3><p>只需要改变材质域、混合模式和着色模式就可以变换材质来满足各种不同的需求。</p><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200515160927312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>Material Domain (材质域）决定了材质属性的评估方式</p><p>Blend Mode（混合模式） 决定了材质的颜色，以及材质与背景融合的方式</p><p>Shading Modeal（着色模型） 决定了输入将如何䄦来创建材质的最终颜色</p><p><u>例如，如果你想实现玻璃材质，应该讲混合模式改为“透明”，根据你是否希望玻璃对光线做出反应，将着色模型改为“无光照”或者“默认带光照”</u></p><p>材质域、混合模式和着色模型不能在运行时更改</p><h3 id="What-is-a-Material？-材质"><a href="#What-is-a-Material？-材质" class="headerlink" title="What is a Material？(材质)"></a>What is a Material？(材质)</h3><p>材质是UE4用于表示并调整对象纹理外观的方式，使用材质编辑器创建。材质实际上是由一块一块的HLSL（高级着色器语言）组成，UE4材质编辑中的许多函数都是直接由HLSL函数构成的。</p><p>材质需要先编译才能在游戏中使用或者显示。一旦材质被编译好了，它就变成静态的了，不能在程序运行时更改。</p><p>可以使用一种材质将其应用到项目中的各种不同材质上。</p><h3 id="材质实例（Meterial-Instance）"><a href="#材质实例（Meterial-Instance）" class="headerlink" title="材质实例（Meterial Instance）"></a>材质实例（Meterial Instance）</h3><p>上个模块我们提到不可以在运行时更改材质，这个特性会对当下的游戏开发带了不少的困扰，例如动态的游戏场景，而材质实例就是为了解决这个问题存在的。</p><p>材质实例是材质的特殊版本。它允许我们在游戏运行的时候修改材质中的参数和纹理而不需要重新编译材质，这让材质实例的迭代变得非常快，所以你几乎可以实时看到变化效果，你还可以通过时间轴和蓝图与材质实例进行交互。</p><p>当你使用单独的材质实例的时候，其性能优势很有限，而当你使用大量的材质实例而不是材质的时候他的性能优势就会逐渐显示出来。</p><p>材质实例非常的灵活，你可以设置一个主材质，然后在材质实例中设置许多的参数以便后期调整材质，而无需编写大量复杂的着色器代码（Shader Code）。</p><h3 id="主材质（Master-Material"><a href="#主材质（Master-Material" class="headerlink" title="主材质（Master Material)"></a>主材质（Master Material)</h3><p>主材质是一种用未完成许多任务的材质，可以在项目中满足对象的不同材质需求</p><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200515164106538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200515164117415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>左侧是Base_Color 可以使用取色器将材质设置成任意颜色</p><p>右侧是纹理参数节点，它允许我们在材质实例中添加任意纹理</p><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200515164341431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>标量参数，标量参数控制标量变量，允许我们更改材质实例中的参数，以便增加或者减少材质实例的某种效果</p><h4 id="主材质的注意事项"><a href="#主材质的注意事项" class="headerlink" title="主材质的注意事项"></a>主材质的注意事项</h4><p>不要尝试将一种主材质用于所有对象，它会让材质臃肿不堪，最终导致性能问题，可以所有的透明物体使用一种材质，所有的半透明使用一种，主角使用一种，武器使用一种。</p><h2 id="主材质的概念"><a href="#主材质的概念" class="headerlink" title="主材质的概念"></a>主材质的概念</h2><h3 id="材质函数（Material-Function）"><a href="#材质函数（Material-Function）" class="headerlink" title="材质函数（Material Function）"></a>材质函数（Material Function）</h3><p>材质函数允许你共享并复用材质图标的部分内容。UE4自带了诸多材质函数，比如确定场景对象的位置、鼠标在屏幕中位置等函数。你可以方便地将代码封装成材质函数，然后通过材质库分享代码。</p><p>材质函数允许你共享材质代码，从而在你调整全局效果时减少维护代码的麻烦</p><h3 id="RGB遮罩打包（RGB-Mask-Packing）"><a href="#RGB遮罩打包（RGB-Mask-Packing）" class="headerlink" title="RGB遮罩打包（RGB Mask Packing）"></a>RGB遮罩打包（RGB Mask Packing）</h3><p>将不同的纹理保存在同一张纹理的RGB通道中，能有效的减少纹理的占用量。</p><p>在使用RGB遮罩打包的时候要注明RGB通道中各自保存的纹理类型。</p><h3 id="静态开关-Static-switches"><a href="#静态开关-Static-switches" class="headerlink" title="静态开关 (Static switches)"></a>静态开关 (Static switches)</h3><p>他允许你启用或者禁用材质中的整条代码路径。<br>        <u>比如你可以将视差法线贴图放在静态开关内，因为其开销很大，所以可以只在需要的时候开启它就可以了。</u></p><h3 id="特性层级开关（Feature-Level-Switch）"><a href="#特性层级开关（Feature-Level-Switch）" class="headerlink" title="特性层级开关（Feature Level Switch）"></a>特性层级开关（Feature Level Switch）</h3><p>它可以让材质在任何目标设备上运行。</p><p><u>例如ES2：用于安卓等移动设备。SM5可以获得最高等级的精细度</u></p><h2 id="实践部分"><a href="#实践部分" class="headerlink" title="实践部分"></a>实践部分</h2><h3 id="主材质"><a href="#主材质" class="headerlink" title="主材质"></a>主材质</h3><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200515223946279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>简单讲一下 </p><p>在UE4中创建一个新的材质，完成相关的蓝图设计。</p><p>这张图创建的材质包括了底色（Base Color)，金属(Metallic)，粗糙程度(Roughness)，法线贴图(Normal) </p><p>在Base_color中有一个Swtich判断显示纹理还是显示取色器颜色。</p><p>Meallic中添加一个参数控制金属光泽</p><p>在Roughness中 lerp()函数为线性插值函数，能上调或调低粗糙度数值，先导入粗糙纹理，在纹理取样类型设置中改为“遮罩”并转换成参数，中间来获取遮罩参数，筛选纹理的RGB通道再连接至lerp函数中的阿尔法通道，通过两个参数的调节控制粗糙程度</p><p>导入法线贴图，将采样类型设置为法线。</p><p>完成主材质制作。 更名、分组对于后期管理很重要。</p><h4 id="改为玻璃对象的主材质"><a href="#改为玻璃对象的主材质" class="headerlink" title="改为玻璃对象的主材质"></a>改为玻璃对象的主材质</h4><p>玻璃的主要属性就是透明，然而我们发现现在主材质的Opacity属性是黑色的，即不可操作。而要打开这个参数我们需要将主材质的属性切换为Translucent，然后就会发现粗糙度相关的点变为了不可操作，而Opacity被打开了。我们按住1点击屏幕创建一个常量，将其链接到Opacity上，即可调整当前材质的透明度。</p><h3 id="材质函数"><a href="#材质函数" class="headerlink" title="材质函数"></a>材质函数</h3><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200516122149422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>创建材质函数，进入蓝图进行创建 <u>控制纹理缩放的材质函数</u></p><p>TexCoord[0]是贴图坐标系，它反映的是只坐标的变化。<br>        Input Texture_Scaling是一个输入节点，在这里我们用来表示坐标缩放的大小。<br>        Multiply是相乘的意思，即将坐标与缩放相乘获得最终的坐标，然后相乘的坐标作为输出结果</p><h4 id="材质函数的应用"><a href="#材质函数的应用" class="headerlink" title="材质函数的应用"></a>材质函数的应用</h4><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200516122727116.png" alt=""></p><p>将材质函数拖入主材质中，MF_Title 为拖入的材质函数，在左侧创建一个参数作为函数的输入，控制缩放的材质大小</p><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200516122852524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>将函数的输出与纹理、粗糙度等建立联系，输入位置为UVs</p><h3 id="材质实例"><a href="#材质实例" class="headerlink" title="材质实例"></a>材质实例</h3><p>材质实例和主材质具有父子关系，子类只能继承或使用父类拥有的属性。</p><h4 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h4><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200516153410274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>1.左侧，右键点击一个材质，在弹出的菜单中选择创建材质实例<br>        2.在内容浏览器的空白处右键可以在材质子菜单中找到材质实例</p><h4 id="材质实例的使用"><a href="#材质实例的使用" class="headerlink" title="材质实例的使用"></a>材质实例的使用</h4><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200516160627181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>可以看见他包含了我刚才创建的Base_Color、Metallic、Normal、Roughness。</p><p>Scalar Parameter Values中包含控制创建的材质函数输入值，相当于其他选项。（因为没有直接连接到主材质上</p><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200516214329317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>在通用字段下可以修改父材质的属性和函数。</p><p>【two sides】：双面。如果勾选中了这个属性，则材质将会双面渲染，双面指的是内面和外面。</p><p>【Dithered LODTransition】：颤化LOD过滤。它用于植被系统。（这个选项违背了父材质系统的初衷，因此请谨慎使用）</p><p>【Shading Model】：如果不想创建材质又想快速的看到效果可以使用这个东西。</p><h2 id="顶点动画"><a href="#顶点动画" class="headerlink" title="顶点动画"></a>顶点动画</h2><p>顶点动画以极低的开销实现复杂对象的微妙运动，如水面、树叶、布料等。顶点动画完全由GPU完成，完全不使用CPU。这使得每一帧的渲染开销都很低。</p><p>缺点是其互动性低，即CPU和我们所处理的逻辑无法获取到动画的偏移量。因此无法用于任何与游戏互动相关的部分，比如交互和碰撞。</p><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200516220152564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>在这颗植物中，只有叶子在随风飘摇，而树干则没有动态的效果。因此我们需要将叶子与树干分离，使用两个静态网格体或者使用两个不同的材质，如上图。其中TreeBark材质为静态的材质，而下面的CherryTree_Wind则是设置了顶点动画的材质。</p><p><img src="https://i2.wp.com/img-blog.csdnimg.cn/20200516220525736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMjIyMDU1,size_16,color_FFFFFF,t_70" alt=""></p><p>其中上侧的TextureSample设置为Mask，将其RGB链接到BaseColor成为底色，而Alpha链接到OpacityMask上。同时拖入一张法线贴图，使其拥有法线效果。</p><p>这样一张静态的材质就做好了。</p><p>而动态的产生依赖于左边的3个模块，分别是两个常量和一个SimpleGrassWind效果，图中链接的3个常量点是必须要设置的参数，设置后将风模块链接到主材质的World Position Offset，即可将风的动态效果映射到世界坐标偏移上，从而产生动态的效果，注意选择双面。</p>]]></content>
      
      
      
        <tags>
            
            <tag> UE4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4笔记（四）</title>
      <link href="/2020/07/16/%E8%99%9A%E5%B9%BB%E5%9B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2020/07/16/%E8%99%9A%E5%B9%BB%E5%9B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="UE4学习笔记（四）"><a href="#UE4学习笔记（四）" class="headerlink" title="UE4学习笔记（四）"></a>UE4学习笔记（四）</h1><h2 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h2><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>规范的命名可以节省大量的时间</p><p>例如：</p><p>SM_Rock_00  - Static Mesh for a Rock version 00  静态网格体的岩石   SM为静态网格体</p><p>T_Rock__00_BC - Base Color Texture for a Rock version 00  岩石的底色纹理 版本是“00” </p><p>SKM_RockBunch_00 - Skeletal Mesh for Rocks version 00  岩石的骨骼网格体 版本是“00”</p><p>_N 法线贴图</p><h3 id="纹理的创建"><a href="#纹理的创建" class="headerlink" title="纹理的创建"></a>纹理的创建</h3><p>纹理的长和宽必须始终是2的幂数（不一定为正方形 ),不规范的纹理无法进行多级渐进纹理，意味着无论摄像机离多远，它所占据的内存不变</p><h3 id="处理阿尔法信息"><a href="#处理阿尔法信息" class="headerlink" title="处理阿尔法信息"></a>处理阿尔法信息</h3><p>嵌入式或单独阿尔法通道</p><p>嵌入阿尔法开销是单独阿尔法的两倍，因为存储再这张纹理中的信息未经压缩就导入进虚幻引擎，意味着它被导入虚幻引擎后，你会得到纹理的完整分辨率</p><p>单独阿尔法的好处是 相对于底色尺寸，能单独控制阿尔法通道大小</p><h3 id="纹理保存和UE4支持的各种纹理格式"><a href="#纹理保存和UE4支持的各种纹理格式" class="headerlink" title="纹理保存和UE4支持的各种纹理格式"></a>纹理保存和UE4支持的各种纹理格式</h3><p>PNG PSD TGA 支持嵌入式阿尔法通道</p><p>BMP FLOAT IPG EXR DDS HDR</p><p>(HDR立方体贴图导入UE4用于光照时，纹理长宽不用是2的幂，唯一)</p><h3 id="多级渐进纹理"><a href="#多级渐进纹理" class="headerlink" title="多级渐进纹理"></a>多级渐进纹理</h3><p>可以将多级渐进纹理看作是纹理的细节层次，纹理被导入UE4后就会生成多级渐进纹理.</p><p><img src="https://s1.ax1x.com/2020/07/19/UWqaB8.png" alt=""><br>多级渐进纹理链  在Level of Deatail - LOD Bias 设置</p><p>假设纹理再屏幕上只占据了100或200个像素点或者离玩家有100米或200米远，我们没必要显示纹理的完整清晰度，在很多使用多级渐进纹理的项目中，你通常会看到第二级或者第三级的渐进纹理，这样可以减少内存消耗，只有当纹理占据当前屏幕很大一部分的时候，你才能看见第一级纹理。</p><h3 id="纹理组（Texture-Group"><a href="#纹理组（Texture-Group" class="headerlink" title="纹理组（Texture Group)"></a>纹理组（Texture Group)</h3><p>纹理组实际上控制着项目中渲染纹理的实际大小、还控制着纹理的缩放程度以及GPU会对纹理采用何种类型的纹理过滤</p><p>假如你发现项目的纹理内存不够用了，纹理组是一种很好的方式来一次性修改LOD偏差</p><p><a href="https://docs.unrealengine.com/zh-CN/Engine/Content/Types/Textures/SupportAndSettings/index.html" target="_blank" rel="noopener">纹理组的官方文档</a></p><h2 id="源控制（协同开发）"><a href="#源控制（协同开发）" class="headerlink" title="源控制（协同开发）"></a>源控制（协同开发）</h2><h3 id="源代码管理软件"><a href="#源代码管理软件" class="headerlink" title="源代码管理软件"></a>源代码管理软件</h3><p>用来存储、跟踪项目文件，并将其共享给其他希望一同开发的人员。</p><p>UE4最常用的是Perforce和Subversion 都能完成三点：</p><p>1.Sync Data (同步数据)</p><p>2.Add/Remove Data （添加删除数据)</p><p>3.Revert Data （恢复数据）</p><h2 id="静态网格体"><a href="#静态网格体" class="headerlink" title="静态网格体"></a>静态网格体</h2><h3 id="材质ID"><a href="#材质ID" class="headerlink" title="材质ID"></a>材质ID</h3><p>所有对象都至少拥有一个材质ID，材质ID有助于确定多边形面使用的材质类型，但对象每多用一个材质ID，他就需要被多渲染一次，例如一个物体上有五个材质ID，他就需要先被渲染五次然后通过一次最终渲染显示出来。</p><h3 id="光照贴图"><a href="#光照贴图" class="headerlink" title="光照贴图"></a>光照贴图</h3><p>光照贴图是专门用来保存光线和阴影复杂信息的纹理，这是因为纹理的开销很低，非常适合存储这类数据，并且将光照计算信息保存在纹理中意味着我们在运行的时候几乎能以零成本获得这些信息。</p><p><img src="https://s1.ax1x.com/2020/07/19/UWqtjP.md.png" alt=""></p><p>左侧为光照贴图，右侧为阴影贴图</p><p>1.光照贴图的RGB通道中存储着不同类型的数值，看起来像五颜六色的维诺图。是由不同的区域的光照信息写入RBG通道中造成的。</p><p>2.阴影贴图的红色和绿色表示不同的阴影信息，所有的阴影数据全部写入了阴影贴图的RGB通道</p><p>光照贴图需要对象上的每一张面都位于0到1的UV空间中，这些面在UV通道中不能相互重叠</p><p><a href="https://docs.unrealengine.com/zh-CN/Engine/Content/Types/StaticMeshes/HowTo/UVChannels/index.html" target="_blank" rel="noopener">使用UV通道的官方文档</a></p><p><a href="https://docs.unrealengine.com/zh-CN/Engine/Content/Types/StaticMeshes/AutoGeneratedLightmaps/index.html" target="_blank" rel="noopener">生成光照贴图UV的官方文档</a></p><h3 id="碰撞"><a href="#碰撞" class="headerlink" title="碰撞"></a>碰撞</h3><p>两种方法进行创建</p><p>1.在DCC中进行创建然后把它和集合体一起导入</p><p>UCX_  碰撞盒命名  UCX _ (FullNameOfMesh) _ Number  在DCC中命名后选择导出FBX，导入UE4中系统会自动根据UCX_将他更改为碰撞盒</p><p>2.在虚幻引擎内进行创建</p><p>（窗口）凸分解可以为不规则物体创建碰撞参数</p><h4 id="过度绘制"><a href="#过度绘制" class="headerlink" title="过度绘制"></a>过度绘制</h4><p>当你处理透明或不透明材质时，会出现过度绘制，他表示许多透明纹理相互重叠时GPU必须重复绘制这些纹理。过度绘制没法彻底消除，只能限制它，多用于植被。</p><h3 id="LOD"><a href="#LOD" class="headerlink" title="LOD"></a>LOD</h3><p>表示”细节层次”，相当于模型的副本，只是三角面数量减少了，有时材质指令的数量也会减小</p><p>如果模型只占屏幕中一两百个像素时，就没有必要显示它的所有面，更好的办法是显示一个分辨率更低的但轮廓相同的模型，只有标准模型一半数量的顶点，从而达到减小内存的方式，在开发VR应用时这点尤为重要，模型都应具备某些细节层次，你可以设置随意数量的细节层次，但超过一定数量后，它实际上就会对你的项目不利。</p><p>网格体面数的缩减量通常应该减少75%、35%最后是12%。</p>]]></content>
      
      
      
        <tags>
            
            <tag> UE4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4笔记（三）</title>
      <link href="/2020/07/12/%E8%99%9A%E5%B9%BB%E5%9B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2020/07/12/%E8%99%9A%E5%B9%BB%E5%9B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="UE4学习笔记（三）"><a href="#UE4学习笔记（三）" class="headerlink" title="UE4学习笔记（三）"></a>UE4学习笔记（三）</h1><h2 id="关于蓝图的概念"><a href="#关于蓝图的概念" class="headerlink" title="关于蓝图的概念"></a>关于蓝图的概念</h2><p>虚幻引擎中的蓝图-<u>可视化脚本系统</u>，可视化意味着将代码变成了一个个可见的模块，蓝图就是封装了很多现成的逻辑，它方便了基础系统的创建和逻辑的工程化分层。小型游戏完全可以使用蓝图制作。</p><p>UE4推出的蓝图系统，更深的意义是帮助设计人员快速设计原型，完成与程序开发人员的交流。</p><h3 id="组件概念"><a href="#组件概念" class="headerlink" title="组件概念"></a>组件概念</h3><p>是可添加到Actor的一项功能，组件不可独立存在，但在将其添加到Actor后，该Actor便可以访问并可以使用该组件所提供的功能。</p><p>一旦添加了用于定义 Actor 的组件，请注意，即使不提供任何 <strong>Blueprint</strong> 脚本（或 C++ 代码）也可将 Actor 放置在关卡中，就像汽车一样（在真实世界中，汽车本身就是一个物体，无需驾驶员告诉汽车该做什么）。 由于“油门踏板”是一个组件，通过脚本或代码，您可表示已踩下了踏板，从而为汽车加速提供了逻辑。 可以此种方式访问每个组件（打开车灯、按喇叭、开启收音机、转动方向盘等）</p><p><u>在这里写到一半的时候，发现自己基础知识掌握不牢固 很多术语不会，所以搁浅了蓝图的学习，重新开始学习整个引擎的构造基础，大概时长为两周。</u></p><h2 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h2><h6 id="在虚幻引擎中，何谓Actor？"><a href="#在虚幻引擎中，何谓Actor？" class="headerlink" title="在虚幻引擎中，何谓Actor？"></a>在虚幻引擎中，何谓Actor？</h6><p>一个或多个组件共同作为单一实体来运行</p><h6 id="有一个大规模团队，并且希望加速资源的共享。您可以做些什么来帮助共享美术资源？"><a href="#有一个大规模团队，并且希望加速资源的共享。您可以做些什么来帮助共享美术资源？" class="headerlink" title="有一个大规模团队，并且希望加速资源的共享。您可以做些什么来帮助共享美术资源？"></a>有一个大规模团队，并且希望加速资源的共享。您可以做些什么来帮助共享美术资源？</h6><p>与团队成员共享衍生数据缓存</p><h6 id="将项目移动到一个虚幻引擎的新预览版本时，您收到一条消息，提示插件不受支持。如何绕过此问题并启动您的项目？"><a href="#将项目移动到一个虚幻引擎的新预览版本时，您收到一条消息，提示插件不受支持。如何绕过此问题并启动您的项目？" class="headerlink" title="将项目移动到一个虚幻引擎的新预览版本时，您收到一条消息，提示插件不受支持。如何绕过此问题并启动您的项目？"></a>将项目移动到一个虚幻引擎的新预览版本时，您收到一条消息，提示插件不受支持。如何绕过此问题并启动您的项目？</h6><p>从.uproject文件中移除插件</p><h6 id="想要将蓝图项目发送给另一名开发者。该开发者需要-uproject文件以及哪些必需文件夹才能运行该项目？"><a href="#想要将蓝图项目发送给另一名开发者。该开发者需要-uproject文件以及哪些必需文件夹才能运行该项目？" class="headerlink" title="想要将蓝图项目发送给另一名开发者。该开发者需要.uproject文件以及哪些必需文件夹才能运行该项目？"></a>想要将蓝图项目发送给另一名开发者。该开发者需要.uproject文件以及哪些必需文件夹才能运行该项目？</h6><p>Content和Config文件夹</p><h6 id="想要覆盖游戏模式，使之应用于整个项目。需要在哪里操作才能实现？"><a href="#想要覆盖游戏模式，使之应用于整个项目。需要在哪里操作才能实现？" class="headerlink" title="想要覆盖游戏模式，使之应用于整个项目。需要在哪里操作才能实现？"></a>想要覆盖游戏模式，使之应用于整个项目。需要在哪里操作才能实现？</h6><p>项目设置</p><h6 id="项目菜单上有一个关卡需要使用单独的游戏模式。会在编辑器的什么地方设置该游戏模式？"><a href="#项目菜单上有一个关卡需要使用单独的游戏模式。会在编辑器的什么地方设置该游戏模式？" class="headerlink" title="项目菜单上有一个关卡需要使用单独的游戏模式。会在编辑器的什么地方设置该游戏模式？"></a>项目菜单上有一个关卡需要使用单独的游戏模式。会在编辑器的什么地方设置该游戏模式？</h6><p>世界场景设置</p><h6 id="将项目设置为当启动编辑器时就会加载贴图文件。可以在“项目设置”中执行此修改吗？"><a href="#将项目设置为当启动编辑器时就会加载贴图文件。可以在“项目设置”中执行此修改吗？" class="headerlink" title="将项目设置为当启动编辑器时就会加载贴图文件。可以在“项目设置”中执行此修改吗？"></a>将项目设置为当启动编辑器时就会加载贴图文件。可以在“项目设置”中执行此修改吗？</h6><p>可以，贴图设置和模式设置就在这里。</p><h6 id="在开发过程中，你决定要添加平台。在哪里可以方便地为项目添加平台？"><a href="#在开发过程中，你决定要添加平台。在哪里可以方便地为项目添加平台？" class="headerlink" title="在开发过程中，你决定要添加平台。在哪里可以方便地为项目添加平台？"></a>在开发过程中，你决定要添加平台。在哪里可以方便地为项目添加平台？</h6><p>项目设置</p><h6 id="场景中有一种粒子效果只在游戏视图下查看时才运行。想要看到这种粒子效果运行，最快的方法是什么？"><a href="#场景中有一种粒子效果只在游戏视图下查看时才运行。想要看到这种粒子效果运行，最快的方法是什么？" class="headerlink" title="场景中有一种粒子效果只在游戏视图下查看时才运行。想要看到这种粒子效果运行，最快的方法是什么？"></a>场景中有一种粒子效果只在游戏视图下查看时才运行。想要看到这种粒子效果运行，最快的方法是什么？</h6><p>按 G 键启用游戏视图（Game View）。</p><p>其它方法</p><p>1.进入“在编辑器中运行（Play in Editor）”模式。</p><p>2.以独立窗口启动游戏。</p><p>3.模拟游戏。</p><h6 id="构建了一个场景，想要从多个预设的角度快速查看它。使用哪个虚幻引擎快捷方式效果最好？"><a href="#构建了一个场景，想要从多个预设的角度快速查看它。使用哪个虚幻引擎快捷方式效果最好？" class="headerlink" title="构建了一个场景，想要从多个预设的角度快速查看它。使用哪个虚幻引擎快捷方式效果最好？"></a>构建了一个场景，想要从多个预设的角度快速查看它。使用哪个虚幻引擎快捷方式效果最好？</h6><p>书签</p><h6 id="优化C盘空间"><a href="#优化C盘空间" class="headerlink" title="优化C盘空间"></a>优化C盘空间</h6><p>1.在epic中的设置 将保管库的位置移到C盘外</p><p>2.缓存位置转移</p><p><a href="https://blog.csdn.net/cc13813194235/article/details/53424866" target="_blank" rel="noopener">CSDN方法</a></p><h6 id="创建了一个基于蓝图的可移植项目。为什么可以将其更改为基于台式机且可使用C-代码的项目？"><a href="#创建了一个基于蓝图的可移植项目。为什么可以将其更改为基于台式机且可使用C-代码的项目？" class="headerlink" title="创建了一个基于蓝图的可移植项目。为什么可以将其更改为基于台式机且可使用C++代码的项目？"></a>创建了一个基于蓝图的可移植项目。为什么可以将其更改为基于台式机且可使用C++代码的项目？</h6><p>初始项目创建是默认设置，而非永久设置。</p><h6 id="为何应在项目设置中设置目标平台？"><a href="#为何应在项目设置中设置目标平台？" class="headerlink" title="为何应在项目设置中设置目标平台？"></a>为何应在项目设置中设置目标平台？</h6><p>设置您的目标平台将禁用非必要的设置</p>]]></content>
      
      
      
        <tags>
            
            <tag> UE4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4笔记（二）</title>
      <link href="/2020/07/04/%E8%99%9A%E5%B9%BB%E5%9B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/07/04/%E8%99%9A%E5%B9%BB%E5%9B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="UE4学习笔记（二）"><a href="#UE4学习笔记（二）" class="headerlink" title="UE4学习笔记（二）"></a>UE4学习笔记（二）</h1><h2 id="关于光照重建问题的解决方法"><a href="#关于光照重建问题的解决方法" class="headerlink" title="关于光照重建问题的解决方法"></a>关于光照重建问题的解决方法</h2><p>有两种解决方法。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>点击构建中的仅构建光照(三角中）。<img src="https://img-blog.csdnimg.cn/20200301164635423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fsenp3,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>右侧搜索light，在光照的变换中将固定改为可移动。</p><p><img src="https://img-blog.csdnimg.cn/20200217135620377.png" alt=""></p><h3 id="光源的移动性差别："><a href="#光源的移动性差别：" class="headerlink" title="光源的移动性差别："></a>光源的移动性差别：</h3><p><strong>Stationary:</strong></p><p>固定光源是保持固定位置不变的光源，但你可以改变光源的亮度和颜色等。这是与静态光源的主要不同之处，静态光源在gameplay期间不会改变。但是，如果在运行时更改亮度，请注意它仅影响直接光照。间接（反射）光照不会改变，因为它是在光照系统（Lightmass）中预先计算的。</p><p><strong>Mobile:</strong></p><p>可移动光源使用完全动态的光照，一切都可以在游戏中改变，但其性能消耗极大，通常而言与光源影响的范围成正比（投射完全动态的光照和阴影。可修改位置、旋转、颜色、亮度、衰减、半径等所有属性。其投射的光照不会烘焙到光照贴图中，在无全局光照方法时不支持间接光照。）</p><p><strong>Static:</strong></p><p>在运行时完全无法更改或移动的光源。这些光源仅在光照贴图中计算，一旦处理完，对性能没有进一步影响。可移动对象不能与静态光源集成，因此静态光源的用途是有限的。</p><p>静态照明仅使用光照贴图，因此它们的阴影会在游戏前烘焙。这意味着，它们不能让移动（动态）对象产生阴影。如果要照明的对象也是静态的，就能够产生面积（接触）阴影。</p><p>主要应用对象是移动平台上的低性能设备。</p><p><img src="https://img-blog.csdnimg.cn/20200217135623122.png" alt=""></p><p><a href="https://docs.unrealengine.com/zh-CN/Engine/Rendering/LightingAndShadows/LightMobility/index.html" target="_blank" rel="noopener">关于光源移动性的具体文档</a></p><h2 id="Landscape室外地形创建（并使用第三人称游戏模式游玩）"><a href="#Landscape室外地形创建（并使用第三人称游戏模式游玩）" class="headerlink" title="Landscape室外地形创建（并使用第三人称游戏模式游玩）"></a>Landscape室外地形创建（并使用第三人称游戏模式游玩）</h2><p>landscape能为世界场景创建地形山脉、山谷、起伏或倾斜的地面，甚至洞穴的开口并通过一系列工具轻松修改其形状和外观</p><h3 id="打开地形工具方法"><a href="#打开地形工具方法" class="headerlink" title="打开地形工具方法"></a>打开地形工具方法</h3><p>1.在模式中选中landscape （快捷键为shift+2）</p><p><img src="https://docs.unrealengine.com/Images/Engine/Landscape/Landscape_Modes.webp" alt=""></p><p>2.在放置actors中的all classes（所有类中）选择地形landscape或通过搜索</p><h3 id="地形创建"><a href="#地形创建" class="headerlink" title="地形创建"></a>地形创建</h3><p>manage中导入你的地形材质创建基础地形大小，Sculpt（雕刻）中修改地形形状，Paint中修改部分地形外观。</p><p><img src="https://docs.unrealengine.com/Images/Engine/Landscape/Editing/Landscape_ManageMode.webp" alt=""></p><p><a href="https://docs.unrealengine.com/zh-CN/Engine/Landscape/QuickStart/3/index.html" target="_blank" rel="noopener">具体关于Sculpt工具使用方法</a></p><h4 id="灰度图和高度图"><a href="#灰度图和高度图" class="headerlink" title="灰度图和高度图"></a>灰度图和高度图</h4><p>在PS中，将高度图的模式改为灰度，16位通道，UE4的格式只支持.RAW和.PNG。</p><h3 id="植被的碰撞设置"><a href="#植被的碰撞设置" class="headerlink" title="植被的碰撞设置"></a>植被的碰撞设置</h3><p><a href="https://docs.unrealengine.com/zh-CN/Engine/Foliage/index.html" target="_blank" rel="noopener">笔刷使用方法</a></p><p>一开始用画笔刷上的物体是没有碰撞体积的。选中要加上碰撞的植物模型，先进入网格体界面，查看是否有简单碰撞，如果没有就用凸包分解创建碰撞模型（性能消耗大）或者直接用盒体等创建。模型碰撞完成之后，进入外部的碰撞预设，改为BlockAll或其他碰撞方式。</p><h3 id="关于官方第三人称模型的使用方法"><a href="#关于官方第三人称模型的使用方法" class="headerlink" title="关于官方第三人称模型的使用方法"></a>关于官方第三人称模型的使用方法</h3><p>两种方式实现。</p><h4 id="1添加第三人称标准模块"><a href="#1添加第三人称标准模块" class="headerlink" title="1添加第三人称标准模块"></a>1添加第三人称标准模块</h4><p>在ThirdPersonBP中选择Character加入场景。点击人体模型，在细节中选择ThirdPersonCharacter（自身）搜索possess,在Pawn中自动控制玩家设为玩家0。</p><h4 id="2游戏模式设置"><a href="#2游戏模式设置" class="headerlink" title="2游戏模式设置"></a>2游戏模式设置</h4><p>在actor中搜索玩家出生点，放置在建立好的世界中。</p><p>打开世界场景设置</p><p>在Game Mode中建立游戏模式，例如第三人称游戏模式或者第一人称。</p><p>在Default Pawn Class中选择操控人物</p><h2 id="项目实现中其他遇到的问题"><a href="#项目实现中其他遇到的问题" class="headerlink" title="项目实现中其他遇到的问题"></a>项目实现中其他遇到的问题</h2><p>我建议看文档 ^_^</p>]]></content>
      
      
      
        <tags>
            
            <tag> UE4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4笔记（一）</title>
      <link href="/2020/07/01/%E8%99%9A%E5%B9%BB%E5%9B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/07/01/%E8%99%9A%E5%B9%BB%E5%9B%9B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="UE4学习笔记（一）"><a href="#UE4学习笔记（一）" class="headerlink" title="UE4学习笔记（一）"></a>UE4学习笔记（一）</h1><p><a href="https://docs.unrealengine.com/zh-CN/index.html" target="_blank" rel="noopener">UE4官方文档</a>  </p><h2 id="界面系统"><a href="#界面系统" class="headerlink" title="界面系统"></a>界面系统</h2><p><img src="https://docs.unrealengine.com/Images/Engine/UI/LevelEditor/DefaultInterface_Windows.jp2" alt="">  </p><ul><li><ol><li>选卡栏和菜单栏  </li></ol></li><li><ol start="2"><li>工具栏  </li></ol></li><li><ol start="3"><li>模式  </li></ol></li><li><ol start="4"><li>内容浏览器  </li></ol></li><li><ol start="5"><li>视口  </li></ol></li><li><ol start="6"><li>世界大纲视图  </li></ol></li><li><ol start="7"><li>详细信息   </li></ol></li></ul><hr><h3 id="选卡栏"><a href="#选卡栏" class="headerlink" title="选卡栏"></a>选卡栏</h3><p>关卡编辑器的顶部有一个选卡，提供了当前正在编辑器的关卡的名称。其他编辑器窗口的选卡可以停靠在该选卡的旁边，以便快速地、方便地进行导航，这和网页浏览器类似。<br><img src="https://docs.unrealengine.com/Images/Engine/UI/LevelEditor/TabBar.jp2" alt=""><br>选卡名称本身将会反应出当前正在编辑的是哪个关卡。这种方式在整个编辑器中都是一致的 - 以当前正在编辑的资源命名编辑器选卡。<br>选卡栏的右侧是当前项目的名称。 </p><hr><h3 id="菜单栏"><a href="#菜单栏" class="headerlink" title="菜单栏"></a>菜单栏</h3><p>它提供了对编辑器中处理关卡时所用通用工具和命令的访问权限。<br><img src="https://docs.unrealengine.com/Images/Engine/UI/LevelEditor/MenuBar/MenuBar_Windows.jp2" alt=""><br>该命令行控制台是个文本框，允许您输入编辑器可以识别的特殊控制台命令。该文本框有自动补全的功能，它可以自动列出和文本框中当前输入的文本匹配的所有命令.  </p><hr><h3 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h3><p><img src="https://docs.unrealengine.com/Images/Engine/UI/LevelEditor/Toolbar/toolbar.jp2" alt=""><br>这里提供了一组快速访问常用工具和操作的命令。  </p><hr><h3 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h3><p>Viewport（视口） 面板是进入到虚幻编辑器中创建的世界的窗口。<br><img src="https://docs.unrealengine.com/Images/Engine/UI/LevelEditor/Viewports/viewports_LE.jp2" alt=""><br>该面板包含了一组视口，每个视口都可以最大化,使其填充整个面板，且提供了在其中一种正交视图(顶视图、侧视图、前视图)或透视图显示世界的功能，使您可以充分地控制显示的内容及显示方式.  </p><hr><h3 id="详细信息"><a href="#详细信息" class="headerlink" title="详细信息"></a>详细信息</h3><p><img src="https://docs.unrealengine.com/Images/Engine/UI/LevelEditor/Details/details_panel.jp2" alt=""><br>包含了关于视口中当前选中对象的信息、工具及功能。它包含了用于移动、旋转及缩放Actor的变换编辑框，显示了选中Actor的所有可编辑属性，并提供了和视口中选中Actor类型相关的其他编辑功能。比如，选中的Actor可以导出到FBX文件中，并可以转换为另一种兼容类型。”选项详情“面板还允许您查看这些选中的Actor所使用的材质（如果存在），并可以快速地打开它们进行编辑。  </p><hr><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>模式（Modes） 面板包含用于编辑器的各种工具模式的选择。这些模式针对特定任务更改关卡编辑器主要行为，例如将新资源放入世界场景、创建几何笔刷和体积、在网格体上绘图、生成植物以及塑造地形。<br><img src="https://docs.unrealengine.com/Images/Engine/UI/LevelEditor/Modes/LE_Tools2.jp2" alt="">  </p><ul><li>TIP:<br>  您可以通过点击选卡右上角的小 “X” 来关闭任何面板。您也可以通过右击面板，然后在弹出的关联菜单中点击 Hide Tab（隐藏选卡），来隐藏任何面板。要想再次显示您已经关闭的面板，在 Window(窗口) 菜单中点击那个面板的名称即可。  </li></ul><p>模式 代表关卡编辑器可以处于的各种不同编辑模式，使得可以启用特定的编辑界面和工作流程来编辑特定类型的 Actor 或几何体  </p><hr><h3 id="世界大纲视图"><a href="#世界大纲视图" class="headerlink" title="世界大纲视图"></a>世界大纲视图</h3><p><img src="https://docs.unrealengine.com/Images/Engine/UI/LevelEditor/SceneOutliner/scene_outliner.jp2" alt=""><br>World Outliner（世界大纲视图） 面板以层次化的树状图形式显示了场景中的所有Actor。您可以从 世界大纲视图 中直接选择及修改Actor。您也可以使用 Info(信息) 下拉列表来打开额外的竖栏来显示关卡、图层或ID名称。  </p><hr><h3 id="图层"><a href="#图层" class="headerlink" title="图层"></a>图层</h3><p>图层（Layers） 面板允许您组织关卡中的Actor<br><img src="https://docs.unrealengine.com/Images/Engine/UI/LevelEditor/Layers/LayerInfra.jp2" alt=""><br>图层提供了快速选择和控制相关Actor组可视性的能力。 您可以使用您的图层来快速整理一个场景， 只留下您正在处理的几何体和Actor。例如，您可能正在处理一个由多个模块组成的 多层建筑。通过将每个楼层分配到一个图层，您可以隐藏您不在处理的每个楼层， 使顶视图更易于管理。 </p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> UE4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于博客文档语法 markdown 记录</title>
      <link href="/2020/06/03/Markdown/"/>
      <url>/2020/06/03/Markdown/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown-用法及注意事项"><a href="#Markdown-用法及注意事项" class="headerlink" title="Markdown 用法及注意事项"></a>Markdown 用法及注意事项</h1><p>我使用的是VS Code<br>另外Typora也挺好用的 都是轻量级编辑器  </p><h2 id="标题使用"><a href="#标题使用" class="headerlink" title="标题使用"></a>标题使用</h2><p> #一级标题<br> ##二级标题<br> ###三级标题<br> 总共六级标题 # 后由空格隔开 </p><hr><h2 id="有序列表和无序列表使用"><a href="#有序列表和无序列表使用" class="headerlink" title="有序列表和无序列表使用"></a>有序列表和无序列表使用</h2><p>有序直接在文字前加1.2.3.符号要和文字之间加上一个字符的空格<br>无序只需在文字前加-或者<em>&emsp;例如：</em> 1 </p><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p>只需要在文本前加入&gt;即可</p></blockquote><hr><h2 id="图片和超链接"><a href="#图片和超链接" class="headerlink" title="图片和超链接"></a>图片和超链接</h2><ul><li>图片为&emsp;：! [ ] ( )  </li><li>超连接为：[ ] ( )<br>方括号中为超链接名称，圆括号中输入网页，进行跳转<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=4012795741,2339581335&fm=26&gp=0.jpg" alt="ue4">  </li></ul><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p><a href="https://www.bilibili.com/" target="_blank" rel="noopener">B站地址</a>  </p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><img src="https://s1.ax1x.com/2020/07/19/UWqUnf.md.png" alt="">  </p><ul><li>将文件夹放在.md文档中，能在博客中直接上传本地图片</li></ul><hr><h2 id="粗体、斜体"><a href="#粗体、斜体" class="headerlink" title="粗体、斜体"></a>粗体、斜体</h2><p><strong>粗体</strong> &emsp;用两个 <em>* 包含文本<br>*斜体</em> &emsp;用一个 * 包含文本<br><strong><em>粗斜体</em></strong> &emsp;用三个 *** 包含文本<br><del>删除线</del> &emsp;用两个 ~~ 包含文本</p><hr><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><blockquote><table><thead><tr><th>性别</th><th align="center">年龄</th><th align="right">职业情况</th></tr></thead><tbody><tr><td>男</td><td align="center">16</td><td align="right">学生</td></tr><tr><td>女</td><td align="center">17</td><td align="right">学生</td></tr><tr><td>男</td><td align="center">18</td><td align="right">学生</td></tr></tbody></table></blockquote><p>效果<br>| 性别        | 年龄           | 职业情况  |<br>| —- |:———:| —–:|<br>| 男      | 16 | 学生 |<br>| 女      | 17      |   学生 |<br>| 男      | 18      |    学生 |<br>默认左对齐 第二行为分割线<br>剧中在两边加：右对齐只在右边加：上文的年龄和职业 </p><hr><h2 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h2><p>用两个` 把代码包裹起来 例如  </p><p><code>cout&lt;&lt;&quot;hello world&quot;</code><br>用三个` 把代码包裹起来 例如</p><pre class=" language-C++"><code class="language-C++">cout<<"hello world"</code></pre><p>在```C++可实现代码高光</p><hr><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p>分割线 三个*  </p></li><li><p>插入一个空格 (non-breaking space)<br>&amp;nbsp； 或    &amp;#160；     或      &amp;#xA0；</p><p>插入两个空格 (en space)<br>&amp;ensp；     或    &amp;#8194；   或      &amp;#x2002；</p><p>插入四个空格 (em space)<br>&amp;emsp；    或    &amp;#8195；   或      &amp;#x2003；</p><p>插入细空格 (thin space)<br>&amp;thinsp；   或     &amp;#8201；  或      &amp;#x2009；</p><p> 注意：不要漏掉分号。    </p></li></ul><hr><p>以后遇到问题会更改博客内容  </p><p><a href="https://blog.csdn.net/witnessai1/article/details/52551362" target="_blank" rel="noopener">Markdown 完整语法</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
